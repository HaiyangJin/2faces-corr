
# Holistic processing effects

Linear mixed-effects models are used to examine the holistic processing effects in the part-whole, standard composite face task, and complete composite face task.

## Steps to obtain the optimal model

1. If the maximal model did not converge, correlations between random effects were removed, making the zero-correlation-parameter (ZCP) model. 
2. Principal component analysis implemented with `rePCA()` function was then used to identify random effects that explained less than 0.1% of the total variances; they were removed from the ZCP model to make the reduced model. 
3. The extended model was built by adding back the correlations between random effects in the reduced model. 
4. If the extended model did not converge, the random effects that explained less than 1% of total variances were identified by `rePCA()` and removed to make the updated extended model; this step was iterated until an extended model converged. 
5. The converged extended model was then compared to the reduced model via `anova()` function and the model that explained the data better (with smaller Bayesian Information Criterion) was used as the optimal model. 
6. All follow-up analyses were performed on the optimal model. 

## Part-whole task

### Accuracy 

#### Maximal model

```{r}
# thisfile <- here("jubail", "lmm_pw_acc_max.rds")
# 
# if (file.exists(thisfile)) {
#   lmm_pw_acc_max <- readRDS(thisfile)
# 
# } else {
#   
#   lmm_pw_acc_max <-
#     glmer(Correct ~ PW * Feature +
#             (PW * Feature | Subject) +
#             (PW * Feature | StimGroup),
#           df_pw,
#           family = binomial(link = "logit"),
#           control = glmerControl(optCtrl = list(maxfun = 1e7)))
#   
#   saveRDS(lmm_pw_acc_max, thisfile)
# }
# 
# summary(lmm_pw_acc_max)
```

#### Zero-correlation-parameter model

```{r}
thisfile <- here("jubail", "lmm_pw_acc_zcp.rds")

if (file.exists(thisfile)) {
  lmm_pw_acc_zcp <- readRDS(thisfile)
  
} else {
  
  lmm_pw_acc_zcp <- 
    glmer(Correct ~ PW * Feature + 
            (PW_C + Feature_C + PW_Feature || Subject) +
            (PW_C + Feature_C + PW_Feature || StimGroup),
          df_pw,
          family = binomial(link = "logit"),
          control = glmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_pw_acc_zcp, thisfile)
}

summary(lmm_pw_acc_zcp)
```

```{r}
summary(rePCA(lmm_pw_acc_zcp))
```
`(PW_Feature | Subject)` will be removed.

#### Reduced model

```{r}
thisfile <- here("jubail", "lmm_pw_acc_rdc.rds")

if (file.exists(thisfile)) {
  lmm_pw_acc_rdc <- readRDS(thisfile)
  
} else {
  
  lmm_pw_acc_rdc <- 
    glmer(Correct ~ PW * Feature + 
            (PW_C + Feature_C || Subject) + # + PW_Feature
            (PW_C + Feature_C + PW_Feature || StimGroup),
          df_pw,
          family = binomial(link = "logit"),
          control = glmerControl(optCtrl = list(maxfun = 1e7)))
  saveRDS(lmm_pw_acc_rdc, thisfile)
}

summary(lmm_pw_acc_rdc)
```

#### Extended model

```{r}
thisfile <- here("jubail", "lmm_pw_acc_etd.rds")

if (file.exists(thisfile)) {
  lmm_pw_acc_etd <- readRDS(thisfile)
  
} else {
  # lmm_pw_acc_etd <- 
  #   glmer(Correct ~ PW * Feature + 
  #           (PW_C + Feature_C | Subject) + # + PW_Feature
  #           (PW_C + Feature_C + PW_Feature | StimGroup),
  #         df_pw,
  #         family = binomial(link = "logit"),
  #         control = glmerControl(optCtrl = list(maxfun = 1e7)))
  # the |grad| is about 0.0110027, so try other optimizer
  
  # use optimx instead
  lmm_pw_acc_etd <- 
    glmer(Correct ~ PW * Feature + 
            (PW_C + Feature_C | Subject) + # + PW_Feature
            (PW_C + Feature_C + PW_Feature | StimGroup),
          df_pw,
          family = binomial(link = "logit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  
  saveRDS(lmm_pw_acc_etd, thisfile)
}

summary(lmm_pw_acc_etd)
```

#### Optimal model

```{r}
anova(lmm_pw_acc_rdc, lmm_pw_acc_etd)
```

`lmm_pw_acc_etd` will be used as the optimal model.
```{r}
lmm_pw_acc_opt <- lmm_pw_acc_etd
```

#### Effects of interest
Accuracy in each condition:
```{r}
emm_pw_acc <- emmeans(lmm_pw_acc_opt, ~ PW)
summary(emm_pw_acc, type = "response")
```

Plot of the part-whole effect in accuracy:
```{r message=FALSE}
emmip(lmm_pw_acc_opt, ~ PW, CIs = TRUE, type = "response") 
```

The part-whole effect in accuracy (differences between log odds ratio):
```{r}
emm_pwe_acc <- contrast(emm_pw_acc, "pairwise")
# summary(emm_pwe_acc, side="=", level=.9, infer=TRUE)
summary(emm_pwe_acc, side=">", infer=TRUE)
```

The part-whole effect in accuracy (ratio of the odds):
```{r}
summary(emm_pwe_acc, side=">", infer=TRUE, type="response") # exp(.872)
```

```{r}
emmeans(lmm_pw_acc_opt, ~ PW + Feature, type = "response")
```

The part-whole effect for each feature:
```{r}
contrast(emmeans(lmm_pw_acc_opt, ~ PW | Feature), "pairwise")
```

Plot for the part-whole effect for each feature:
```{r}
emmip(lmm_pw_acc_opt, ~ PW | Feature, CIs = TRUE, type = "response") 
```

#### Plot

```{r}
plot_pw_acc <- emm_pw_acc %>%
  summary(type="response") %>% 
  as_tibble() %>% 
  mutate(task = "PW") %>% 
  ggplot(aes(PW, prob, group=task)) +
  geom_point(size = 2, color = two_colors[1]) + # position = position_dodge(width = 0.1),
  geom_line(linetype="solid", color = two_colors[1], size = 0.8) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), size=1.5, width=0, 
                alpha = .6, # position = position_dodge(width = 0.1),
                color = two_colors[1],
                show.legend = F) + 
  coord_cartesian(ylim = c(.75, 1)) +  # set the limit for y axis c(0, 1100)
  labs(x = "Condition", y = "Accuracy") +  # set the names for main, x and y axises
  # geom_text(label = c("***", ""),
  #           color = "red",
  #           size = 6, nudge_y = 0.05, nudge_x = 0.5) + # add starts to the significant columns
  NULL
# ggsave(filename = "pw_acc.pdf", plot_pw_acc, width = 8, height = 6)
plot_pw_acc
```


### Correct response times

#### Maximal model

```{r}
# thisfile <- here("jubail", "lmm_pw_rt_max.rds")
# 
# if (file.exists(thisfile)) {
#   lmm_pw_rt_max <- readRDS(thisfile)
# 
# } else {
#   lmm_pw_rt_max <-
#     lmer(log(RT) ~ PW * Feature +
#            (PW * Feature | Subject) +
#            (PW * Feature | StimGroup),
#          filter(df_pw, Correct),
#          control = lmerControl(optCtrl = list(maxfun = 1e7)))
#   
#   saveRDS(lmm_pw_rt_max, thisfile)
# }
# 
# summary(lmm_pw_rt_max)
```

#### Zero-correlation-parameter model

```{r}
thisfile <- here("jubail", "lmm_pw_rt_zcp.rds")

if (file.exists(thisfile)) {
  lmm_pw_rt_zcp <- readRDS(thisfile)
  
} else {
  
  lmm_pw_rt_zcp <- 
    lmer(log(RT) ~ PW * Feature + 
           (PW_C + Feature_C + PW_Feature || Subject) +
           (PW_C + Feature_C + PW_Feature || StimGroup),
         filter(df_pw, Correct),
         control = lmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_pw_rt_zcp, thisfile)
}

summary(lmm_pw_rt_zcp)
```

```{r}
summary(rePCA(lmm_pw_rt_zcp))
```
No random effects need to be removed. Therefore, we apply the extended model (i.e., the maximal model in this case) directly.

#### Extended model

```{r}
thisfile <- here("jubail", "lmm_pw_rt_etd.rds")

if (file.exists(thisfile)) {
  lmm_pw_rt_etd <- readRDS(thisfile)
  
} else {
  lmm_pw_rt_etd <- 
    lmer(log(RT) ~ PW * Feature + 
           (PW_C + Feature_C + PW_Feature | Subject) +
           (PW_C + Feature_C + PW_Feature | StimGroup),
         filter(df_pw, Correct),
         control = lmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_pw_rt_etd, thisfile)
}

summary(lmm_pw_rt_etd)
```

```{r}
summary(rePCA(lmm_pw_rt_etd))
```

#### Optimal model

```{r}
anova(lmm_pw_rt_zcp, lmm_pw_rt_etd, refit=FALSE)
```

Use `lmm_pw_rt_etd` as the optimal model.
```{r}
lmm_pw_rt_opt <- lmm_pw_rt_zcp
```

#### Effects of interest

Correct RT in each condition:
```{r}
emm_pw_rt <- emmeans(lmm_pw_rt_opt, ~ PW)
summary(emm_pw_rt, type="response")
```

Plot for the each condition (RT):
```{r}
emmip(lmm_pw_rt_opt, ~ PW, CIs = TRUE, type = "response") 
```

The part-whole effect in RT (differences between log RT):
```{r}
emm_pwe_rt <- contrast(emm_pw_rt, "pairwise")
summary(emm_pwe_rt, side="<", infer=TRUE)
```

The part-whole effect in RT (ratio of the RT):
```{r}
summary(emm_pwe_rt, side="<", infer=TRUE, type = "response") # exp(-0.032)
```

Correct RT in each condition including features:
```{r}
emmeans(lmm_pw_rt_opt, ~ PW + Feature, type="response")
```

The part-whole effect for each feature:
```{r}
contrast(emmeans(lmm_pw_rt_opt, ~ PW | Feature), "pairwise")
```

Plot for the conditions of each feature:
```{r}
emmip(lmm_pw_rt_opt, ~ PW | Feature, CIs = TRUE, type = "response") 
```

#### Plot

```{r}
plot_pw_rt <- emm_pw_rt %>% 
  summary(type = "response") %>% 
  as_tibble() %>% 
  mutate(task = "PW") %>% 
  ggplot(aes(y = response, x = PW, group = task)) +
  geom_point(size = 2, color = two_colors[1]) + # position = position_dodge(width = 0.1), 
  geom_line(linetype = "solid", # position = position_dodge(width = 0.1),
            color = two_colors[1],
            size = 0.8) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), size=1.5, width=0, 
                alpha = .6, # position = position_dodge(width = 0.1),
                color = two_colors[1],
                show.legend = F) + 
  coord_cartesian(ylim = c(1100, 1300)) +  # set the limit for y axis c(0, 1100)
  labs(x = "Condition", y = "Correct response times (ms)") +  # set the names for main, x and y axises
  # geom_text(label = c("***", ""),
  #           color = "red",
  #           size = 6, nudge_y = 75, nudge_x = 0.5) + # add starts to the significant columns
  NULL
# ggsave(filename = "pw_rt.pdf", plot_pw_rt, width = 8, height = 6)
plot_pw_rt
```


## Standard composite face task

### Accuracy 
#### Maximal model
```{r}
# thisfile <- here("jubail", "lmm_scf_acc_max.rds")
# 
# if (file.exists(thisfile)) {
#   lmm_scf_acc_max <- readRDS(thisfile)
# 
# } else {
#   lmm_scf_acc_max <-
#     glmer(Correct ~ Alignment +
#             (Alignment | Subject) +
#             (Alignment | StimGroup),
#           df_scf,
#           family = binomial(link = "logit"),
#           control = glmerControl(optCtrl = list(maxfun = 1e7)))
#   
#   saveRDS(lmm_scf_acc_max, thisfile)
# }
# 
# summary(lmm_scf_acc_max)
```

#### Zero-correlation-parameter model

```{r}
thisfile <- here("jubail", "lmm_scf_acc_zcp.rds")

if (file.exists(thisfile)) {
  lmm_scf_acc_zcp <- readRDS(thisfile)
  
} else {
  
  lmm_scf_acc_zcp <- 
    glmer(Correct ~ Alignment + 
            (Ali_C || Subject) +
            (Ali_C || StimGroup),
          df_scf,
          family = binomial(link = "logit"),
          control = glmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_scf_acc_zcp, thisfile)
}

summary(lmm_scf_acc_zcp)
```

```{r}
summary(rePCA(lmm_scf_acc_zcp))
```
No random effects need to be removed. Therefore, we apply the extended model (i.e., the maximal model in this case) directly.

#### Extended model

```{r}
thisfile <- here("jubail", "lmm_scf_acc_etd.rds")

if (file.exists(thisfile)) {
  lmm_scf_acc_etd <- readRDS(thisfile)
  
} else {
  
  lmm_scf_acc_etd <- 
    glmer(Correct ~ Alignment + 
            (Ali_C | Subject) +
            (Ali_C | StimGroup),
          df_scf,
          family = binomial(link = "logit"),
          control = glmerControl(optCtrl = list(maxfun = 1e7)))
  saveRDS(lmm_scf_acc_etd, thisfile)
}

summary(lmm_scf_acc_etd)
```

```{r}
summary(rePCA(lmm_scf_acc_etd))
```
By-item `(Intercept)` will be removed.

```{r}
thisfile <- here("jubail", "lmm_scf_acc_etd2.rds")

if (file.exists(thisfile)) {
  
  lmm_scf_acc_etd2 <- readRDS(thisfile)
  
} else {
  
  lmm_scf_acc_etd2 <- 
    glmer(Correct ~ Alignment + 
            (Ali_C | Subject) +
            (0 + Ali_C | StimGroup),
          df_scf,
          family = binomial(link = "logit"),
          control = glmerControl(optCtrl = list(maxfun = 1e7)))
  saveRDS(lmm_scf_acc_etd2, thisfile)
}

summary(lmm_scf_acc_etd2)
```

#### Optimal model

```{r}
anova(lmm_scf_acc_zcp, lmm_scf_acc_etd2, refit=FALSE)
```

`lmm_scf_acc_zcp` will be used as the optimal model.
```{r}
lmm_scf_acc_opt <- lmm_scf_acc_zcp
```

#### Effects of interest
Accuracy in each condition:
```{r}
emm_scf_acc <- emmeans(lmm_scf_acc_opt, ~ Alignment)
summary(emm_scf_acc, type="response")
```

Plot of accuracy:
```{r}
emmip(lmm_scf_acc_opt, ~ Alignment, CIs = TRUE, type = "response") 
```

The composite effect in accuracy (differences between log odds):
```{r}
emm_scfe_acc <- contrast(emm_scf_acc, "pairwise")
summary(emm_scfe_acc, side="<", infer=TRUE)
```

The composite effect in accuracy (differences between log odds):
```{r}
summary(emm_scfe_acc, side="<", infer=TRUE, type="response")
```

#### Plot

```{r}
plot_scf_acc <- emm_scf_acc %>%
  summary(type="response") %>% 
  as_tibble() %>% 
  mutate(task = "SCF",
         Alignment = fct_recode(Alignment, aligned="ali", misaligned="mis")) %>% 
  ggplot(aes(Alignment, prob, group=task)) +
  geom_point(size = 2, color = two_colors[2]) + # position = position_dodge(width = 0.1),
  geom_line(linetype="dashed", color = two_colors[2], size = 0.8) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), size=1.5, width=0, 
                alpha = .6, # position = position_dodge(width = 0.1),
                color = two_colors[2],
                show.legend = F) + 
  coord_cartesian(ylim = c(.75, 1)) +  # set the limit for y axis c(0, 1100)
  labs(x = "Alignment", y = "Accuracy") +  # set the names for main, x and y axises
  # geom_text(label = c("***", ""),
  #           color = "red",
  #           size = 6, nudge_y = .08, nudge_x = 0.5) + # add starts to the significant columns
  NULL
# ggsave(filename = "scf_acc.pdf", plot_scf_acc, width = 8, height = 6)
plot_scf_acc
```

### Correct response times

#### Maximal model
```{r}
# thisfile <- here("jubail", "lmm_scf_rt_max.rds")
# 
# if (file.exists(thisfile)) {
#   lmm_scf_rt_max <- readRDS(thisfile)
# 
# } else {
#   
#   lmm_scf_rt_max <-
#     lmer(log(RT) ~ Alignment +
#            (Alignment | Subject) +
#            (Alignment | StimGroup),
#          filter(df_scf, Correct),
#          control = lmerControl(optCtrl = list(maxfun = 1e7)))
#   
#   saveRDS(lmm_scf_rt_max, thisfile)
# }
# 
# summary(lmm_scf_rt_max)
```


#### Zero-correlation-parameter model

```{r}
thisfile <- here("jubail", "lmm_scf_rt_zcp.rds")

if (file.exists(thisfile)) {
  lmm_scf_rt_zcp <- readRDS(thisfile)
  
} else {
  
  lmm_scf_rt_zcp <- 
    lmer(log(RT) ~ Alignment + 
           (Ali_C || Subject) +
           (Ali_C || StimGroup),
         filter(df_scf, Correct),
         control = lmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_scf_rt_zcp, thisfile)
}

summary(lmm_scf_rt_zcp)
```

```{r}
summary(rePCA(lmm_scf_rt_zcp))
```
No random effects need to be removed. Therefore, we apply the extended model (i.e., the maximal model in this case) directly.

#### Extended model
```{r}
thisfile <- here("jubail", "lmm_scf_rt_etd.rds")

if (file.exists(thisfile)) {
  lmm_scf_rt_etd <- readRDS(thisfile)
  
} else {
  
  lmm_scf_rt_etd <-
    lmer(log(RT) ~ Alignment +
           (Ali_C | Subject) +
           (Ali_C | StimGroup),
         filter(df_scf, Correct),
         control = lmerControl(optCtrl = list(maxfun = 1e7)))
  saveRDS(lmm_scf_rt_etd, thisfile)
}

summary(lmm_scf_rt_etd)
```

#### Optimal model
```{r}
anova(lmm_scf_rt_zcp, lmm_scf_rt_etd, refit=FALSE)
```

`lmm_scf_rt_etd` will be used as the optimal model.
```{r}
lmm_scf_rt_opt <- lmm_scf_rt_zcp
```

#### Effects of interest
Correct RT in each condition:
```{r}
emm_scf_rt <- emmeans(lmm_scf_rt_opt, ~ Alignment)
summary(emm_scf_rt, type="response")
```

Plot of RT:
```{r}
emmip(lmm_scf_rt_opt, ~ Alignment, CIs = TRUE, type = "response") 
```

The composite effect in RT (differences between log RT):
```{r}
emm_scfe_rt <- contrast(emm_scf_rt, "pairwise")
summary(emm_scfe_rt, side=">", infer=TRUE)
```

The composite effect in RT (ratio of the RT):
```{r}
summary(emm_scfe_rt, side=">", infer=TRUE, type = "response") # exp(0.0805)
```

#### Plot

```{r}
plot_scf_rt <- emm_scf_rt %>% 
  summary(type = "response") %>% 
  as_tibble() %>% 
  mutate(task = "SCF",
         Alignment = fct_recode(Alignment, aligned="ali", misaligned="mis")) %>% 
  ggplot(aes(y = response, x = Alignment, group = task)) +
  geom_point(size = 2, color = two_colors[2]) + # position = position_dodge(width = 0.1), 
  geom_line(linetype = "dashed", # position = position_dodge(width = 0.1),
            color = two_colors[2],
            size = 0.8) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), size=1.5, width=0, 
                alpha = .6, # position = position_dodge(width = 0.1),
                color = two_colors[2],
                show.legend = F) + 
  coord_cartesian(ylim = c(600, 750)) +  # set the limit for y axis c(0, 1100)
  labs(x = "Alignment", y = "Correct response times (ms)") +  # set the names for main, x and y axises
  # geom_text(label = c("***", ""),
  #           color = "red",
  #           size = 6, nudge_y = 75, nudge_x = 0.5) + # add starts to the significant columns
  NULL
# ggsave(filename = "scf_rt.pdf", plot_scf_rt, width = 8, height = 6)
plot_scf_rt
```

## Complete composite face task

### Sensitivity d'

#### Maximal model
```{r}
# thisfile <- here("jubail", "lmm_ccf_d_max.rds")
# 
# if (file.exists(thisfile)) {
#   lmm_ccf_d_max <- readRDS(thisfile)
#   
# } else {
#   
#   lmm_ccf_d_max <-
#     glmer(isSame ~ Congruency * Alignment * SD + Cue +
#             (Congruency * Alignment * SD | Subject) +
#             (Congruency * Alignment * SD | StimGroup),
#           df_ccf,
#           family = binomial(link = "probit"),
#           control = glmerControl(optCtrl = list(maxfun = 1e7)))
#   
#   saveRDS(lmm_ccf_d_max, thisfile)
# }
# 
# summary(lmm_ccf_d_max)
```

#### Zero-correlation-parameter model
```{r}
thisfile <- here("jubail", "lmm_ccf_d_zcp.rds")

if (file.exists(thisfile)) {
  lmm_ccf_d_zcp <- readRDS(thisfile)
  
} else {
  
  lmm_ccf_d_zcp <- 
    glmer(isSame ~ Congruency * Alignment * SD + Cue +
            (Con_C + Ali_C + SD_C + 
               Con_Ali + Con_SD + Ali_SD + 
               Con_Ali_SD || Subject) +
            (Con_C + Ali_C + SD_C + 
               Con_Ali + Con_SD + Ali_SD + 
               Con_Ali_SD || StimGroup),
          df_ccf,
          family = binomial(link = "probit"),
          control = glmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_ccf_d_zcp, thisfile)
}

summary(lmm_ccf_d_zcp)
```

```{r}
summary(rePCA(lmm_ccf_d_zcp))
```

By-subject `Con_Ali`, `Con_C`, `Ali_SD`, and by-item `Con_Ali_SD` were removed.

#### Reduced model
```{r}
thisfile <- here("jubail", "lmm_ccf_d_rdc.rds")

if (file.exists(thisfile)) {
  lmm_ccf_d_rdc <- readRDS(thisfile)
  
} else {
  
  lmm_ccf_d_rdc <- 
    glmer(isSame ~ Congruency * Alignment * SD + Cue +
            (Ali_C + SD_C + # Con_C + 
               Con_SD +  # Con_Ali + Ali_SD +
               Con_Ali_SD || Subject) +
            (Con_C + Ali_C + SD_C + 
               Con_Ali + Con_SD + Ali_SD # + 
             || StimGroup), # Con_Ali_SD
          df_ccf,
          family = binomial(link = "probit"),
          control = glmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_ccf_d_rdc, thisfile)
}

summary(lmm_ccf_d_rdc)
```

```{r}
summary(rePCA(lmm_ccf_d_rdc))
```

#### Extended model
```{r}
thisfile <- here("jubail", "lmm_ccf_d_etd.rds")

if (file.exists(thisfile)) {
  lmm_ccf_d_etd <- readRDS(thisfile)
  
} else {
  lmm_ccf_d_etd <-
    glmer(isSame ~ Congruency * Alignment * SD + Cue +
            (Ali_C + SD_C + # Con_C + 
               Con_SD +  # Con_Ali + Ali_SD +
               Con_Ali_SD | Subject) +
            (Con_C + Ali_C + SD_C + 
               Con_Ali + Con_SD + Ali_SD # + 
             | StimGroup), # Con_Ali_SD
          df_ccf,
          family = binomial(link = "probit"),
          control = glmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_ccf_d_etd, thisfile)
}

summary(lmm_ccf_d_etd)
```

```{r}
summary(rePCA(lmm_ccf_d_etd))
```

By-subject `Ali_C`, by-item `Ali_C`, `Con_C`, `Ali_SD`, and `Con_Ali` were removed.

```{r}
thisfile <- here("jubail", "lmm_ccf_d_etd2.rds")

if (file.exists(thisfile)) {
  lmm_ccf_d_etd2 <- readRDS(thisfile)
  
} else {
  
  lmm_ccf_d_etd2 <-
    glmer(isSame ~ Congruency * Alignment * SD + Cue +
            (SD_C + # Con_C + Ali_C + 
               Con_SD +  # Con_Ali + Ali_SD +
               Con_Ali_SD | Subject) +
            (SD_C + # Con_C + Ali_C + 
               Con_SD  # + + Ali_SD Con_Ali + 
             | StimGroup), # Con_Ali_SD
          df_ccf,
          family = binomial(link = "probit"),
          control = glmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_ccf_d_etd2, thisfile)
}

summary(lmm_ccf_d_etd2)
```

```{r}
summary(rePCA(lmm_ccf_d_etd2))
```

By-subject `(Intercept)` and by-item `Con_SD` were removed.

```{r}
thisfile <- here("jubail", "lmm_ccf_d_etd3.rds")

if (file.exists(thisfile)) {
  lmm_ccf_d_etd3 <- readRDS(thisfile)
  
} else {
  
  lmm_ccf_d_etd3 <-
    glmer(isSame ~ Congruency * Alignment * SD + Cue +
            (0 + SD_C + # Con_C + Ali_C + 
               Con_SD +  # Con_Ali + Ali_SD +
               Con_Ali_SD | Subject) +
            (SD_C # +  Con_C + Ali_C + 
             # + Con_SD + Ali_SD Con_Ali + 
             | StimGroup), # Con_Ali_SD
          df_ccf,
          family = binomial(link = "probit"),
          control = glmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_ccf_d_etd3, thisfile)
}

summary(lmm_ccf_d_etd3)
```

```{r}
summary(rePCA(lmm_ccf_d_etd3))
```

By-subject `Con_Ali_SD` was removed.

```{r}
thisfile <- here("jubail", "lmm_ccf_d_etd4.rds")

if (file.exists(thisfile)) {
  lmm_ccf_d_etd4 <- readRDS(thisfile)
  
} else {
  lmm_ccf_d_etd4 <-
    glmer(isSame ~ Congruency * Alignment * SD + Cue +
            (0 + SD_C + # Con_C + Ali_C + 
               Con_SD  # Con_Ali + Ali_SD + + 
             | Subject) + # Con_Ali_SD
            (SD_C # +  Con_C + Ali_C + 
             # + Con_SD + Ali_SD Con_Ali + 
             | StimGroup), # Con_Ali_SD
          df_ccf,
          family = binomial(link = "probit"),
          control = glmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_ccf_d_etd4, thisfile)
}

summary(lmm_ccf_d_etd4)
```

```{r}
summary(rePCA(lmm_ccf_d_etd4))
```

#### Optimal model
```{r}
anova(lmm_ccf_d_rdc, lmm_ccf_d_etd4, refit=FALSE)
```

`lmm_ccf_d_rdc` is used as the optimal model.
```{r}
lmm_ccf_d_opt <- lmm_ccf_d_rdc
```

#### Effects of interest
Hit and false alarm rates:
```{r}
(emm_ccf_probit <- emmeans(lmm_ccf_d_opt, ~ Congruency + Alignment + SD, type = "response"))
```

Sensitivity d' in each condition:
```{r}
emm_ccf_d <- contrast(emm_ccf_probit, "pairwise", simple="SD")
summary(emm_ccf_d[1:4], infer=TRUE)
```

Plot of d' in each condition:
```{r}
emmip(emm_ccf_d, Congruency ~ Alignment, CIs = TRUE)
```
Congruency effect of d' for the aligned condition:
```{r}
emm_con_d <- contrast(emm_ccf_probit, interaction="pairwise", by="Alignment")
summary(emm_con_d[1], side=">", infer=TRUE)
```

Composite effect of d':
```{r}
emm_ccfe_d <- contrast(emm_ccf_probit, interaction="pairwise")
summary(emm_ccfe_d, side=">", infer=TRUE)
```

```{r}
# facilitation and interference of d'
contrast(emm_ccf_probit, interaction="pairwise", by="Congruency")
```


#### Plot

```{r}
plot_ccf_d <- emm_ccf_d %>%
  summary(infer=TRUE) %>% 
  as_tibble() %>% 
  mutate(Congruency = fct_recode(Congruency, congruent="con", incongruent="inc"),
         Alignment = fct_recode(Alignment, aligned="ali", misaligned="mis")) %>%
  ggplot(aes(Alignment, estimate, color=Congruency, group=Congruency)) +
  geom_point(size = 2) + # position = position_dodge(width = 0.1),
  geom_line(aes(linetype = Congruency), size = 0.8) +
  scale_linetype_manual(values=c("solid", "dashed")) +
  scale_color_manual(values=two_colors) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), size=1.5, width=0, 
                alpha = .6, # position = position_dodge(width = 0.1),
                show.legend = F) + 
  coord_cartesian(ylim = c(0,3.2)) +  # set the limit for y axis c(0, 1100)
  labs(y = expression("Sensitivity"~italic("d'")), fill = "Congruency") +  # set the names for main, x and y axises
  # geom_text(label = c("***", "", "", ""), 
  #           color = "red", 
  #           size = 6, nudge_y = 0.5, nudge_x = 0.5) + # add starts to the significant columns
  NULL
# ggsave(filename = "ccf_d.pdf", plot_ccf_d, width = 8, height = 6)
plot_ccf_d
```

```{r}
plot_ccf_d_fi <- contrast(emm_ccf_probit, interaction="pairwise", by="Congruency") %>% 
  summary(infer=TRUE) %>% 
  as_tibble() %>% 
  mutate(Congruency = fct_recode(Congruency, congruent="con", incongruent="inc")) %>% 
  ggplot(aes(y = estimate, x = Congruency, color = Congruency)) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), size=1.5, width=0, 
                alpha = .6) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_color_manual(values=two_colors) +
  # coord_cartesian(ylim = ylimit_cf_fi_d) +  # set the limit for y axis c(0, 1100)
  labs(x = "Congruency", y = expression(italic("d'")~"(aligned-misaligned)")) +  # set the names for main, x and y axises
  theme(legend.position = "none") +
  NULL
# ggsave(filename = "ccf_d_fi.pdf", plot_ccf_d_fi, width = 4, height = 6)
plot_ccf_d_fi
```

### Correct response times

#### Maximal model
```{r}
# thisfile <- here("jubail", "lmm_ccf_rt_max.rds")
# 
# if (file.exists(thisfile)) {
#   lmm_ccf_rt_max <- readRDS(thisfile)
#   
# } else {
#   
#   lmm_ccf_rt_max <-
#     lmer(log(RT) ~ Congruency * Alignment + SD + Cue +
#            (Congruency * Alignment | Subject) +
#            (Congruency * Alignment | StimGroup),
#          filter(df_ccf, Correct),
#          control = lmerControl(optCtrl = list(maxfun = 1e7)))
#   
#   saveRDS(lmm_ccf_rt_max, thisfile)
# }
# 
# summary(lmm_ccf_rt_max)
```

#### Zero-correlation-parameter model
```{r}
thisfile <- here("jubail", "lmm_ccf_rt_zcp.rds")

if (file.exists(thisfile)) {
  lmm_ccf_rt_zcp <- readRDS(thisfile)
  
} else {
  
  lmm_ccf_rt_zcp <- 
    lmer(log(RT) ~ Congruency * Alignment + SD + Cue + 
           (Con_C + Ali_C + Con_Ali || Subject) +
           (Con_C + Ali_C + Con_Ali || StimGroup),
         filter(df_ccf, Correct),
         control = lmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_ccf_rt_zcp, thisfile)
}

summary(lmm_ccf_rt_zcp)
```

```{r}
summary(rePCA(lmm_ccf_rt_zcp))
```

By-item `Con_Ali` was removed.

#### Reduced model
```{r}
thisfile <- here("jubail", "lmm_ccf_rt_rdc.rds")

if (file.exists(thisfile)) {
  lmm_ccf_rt_rdc <- readRDS(thisfile)
  
} else {
  
  lmm_ccf_rt_rdc <- 
    lmer(log(RT) ~ Congruency * Alignment + SD + Cue + 
           (Con_C + Ali_C + Con_Ali || Subject) +
           (Con_C + Ali_C || StimGroup), # + Con_Ali
         filter(df_ccf, Correct),
         control = lmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_ccf_rt_rdc, thisfile)
}

summary(lmm_ccf_rt_rdc)
```

```{r}
summary(rePCA(lmm_ccf_rt_rdc))
```

#### Extended model
```{r}
thisfile <- here("jubail", "lmm_ccf_rt_etd.rds")

if (file.exists(thisfile)) {
  lmm_ccf_rt_etd <- readRDS(thisfile)
  
} else {
  
  lmm_ccf_rt_etd <- 
    lmer(log(RT) ~ Congruency * Alignment + SD + Cue + 
           (Con_C + Ali_C + Con_Ali | Subject) +
           (Con_C + Ali_C | StimGroup), # + Con_Ali
         filter(df_ccf, Correct),
         control = lmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_ccf_rt_etd, thisfile)
}

summary(lmm_ccf_rt_etd)
```

```{r}
summary(rePCA(lmm_ccf_rt_etd))
```
By-subject `Con_C` was removed.

```{r}
thisfile <- here("jubail", "lmm_ccf_rt_etd2.rds")

if (file.exists(thisfile)) {
  lmm_ccf_rt_etd2 <- readRDS(thisfile)
  
} else {
  
  lmm_ccf_rt_etd2 <- 
    lmer(log(RT) ~ Congruency * Alignment + SD + Cue + 
           (Ali_C + Con_Ali | Subject) + # Con_C + 
           (Con_C + Ali_C | StimGroup), # + Con_Ali
         filter(df_ccf, Correct),
         control = lmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_ccf_rt_etd2, thisfile)
}

summary(lmm_ccf_rt_etd2)
```

```{r}
summary(rePCA(lmm_ccf_rt_etd2))
```
By-item `Con_C` was removed.

```{r}
thisfile <- here("jubail", "lmm_ccf_rt_etd3.rds")

if (file.exists(thisfile)) {
  lmm_ccf_rt_etd3 <- readRDS(thisfile)
  
} else {
  
  lmm_ccf_rt_etd3 <- 
    lmer(log(RT) ~ Congruency * Alignment + SD + Cue + 
           (Ali_C + Con_Ali | Subject) + # Con_C + 
           (Ali_C | StimGroup), # + Con_Ali + Con_C + 
         filter(df_ccf, Correct),
         control = lmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_ccf_rt_etd3, thisfile)
}

summary(lmm_ccf_rt_etd3)
```

```{r}
summary(rePCA(lmm_ccf_rt_etd3))
```

#### Optimal model
```{r}
anova(lmm_ccf_rt_rdc, lmm_ccf_rt_etd3, refit=FALSE)
```

`lmm_ccf_rt_rdc` is used as the optimal model.
```{r}
lmm_ccf_rt_opt <- lmm_ccf_rt_rdc
```

#### Effects of interest
RT in each condition:
```{r}
emm_ccf_rt <- emmeans(lmm_ccf_rt_opt, ~ Congruency + Alignment)
summary(emm_ccf_rt, type = "response")
```

Plot of RT:
```{r}
emmip(lmm_ccf_rt_opt, Congruency ~ Alignment, CIs = TRUE, type = "response") 
```

Congruency effect of RT in the aligned condition (differences of log RT):
```{r}
emm_con_rt <- contrast(emm_ccf_rt, "pairwise", by = "Alignment")
summary(emm_con_rt[1], side="<", infer=TRUE)
```

Congruency effect of RT in the aligned condition (ratio of RT):
```{r}
summary(emm_con_rt[1], side="<", infer=TRUE, type="response") # exp(-0.0599)
```

Composite effect of RT (differences of log RT):
```{r}
emm_ccfe_rt <- contrast(emm_ccf_rt, interaction="pairwise")
summary(emm_ccfe_rt, side="<", infer=TRUE)
```

Composite effect of RT (ratio of RT):
```{r}
summary(emm_ccfe_rt, side="<", infer=TRUE, type = "response") # exp(-0.0405)
```

```{r}
# facilitation and interference of d'
contrast(emm_ccf_rt, "pairwise", by="Congruency")
```

#### Plot

```{r}
plot_ccf_rt <- emm_ccf_rt %>% 
  summary(type = "response") %>% 
  as_tibble() %>% 
  mutate(Congruency = fct_recode(Congruency, congruent="con", incongruent="inc"),
         Alignment = fct_recode(Alignment, aligned="ali", misaligned="mis")) %>%
  ggplot(aes(y = response, x = Alignment, color = Congruency, group = Congruency)) +
  geom_point(size = 2) + # position = position_dodge(width = 0.1), 
  geom_line(aes(linetype = Congruency), # position = position_dodge(width = 0.1),
            size = 0.8) +
  scale_linetype_manual(values=c("solid", "dashed"))+
  scale_color_manual(values=two_colors) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), size=1.5, width=0, 
                alpha = .6, # position = position_dodge(width = 0.1),
                show.legend = F) + 
  coord_cartesian(ylim = c(800, 1000)) +  # set the limit for y axis c(0, 1100)
  labs(y = "Correct response times (ms)", fill = "Congruency") +  # set the names for main, x and y axises
  # geom_text(label = c("", "***", "", ""), 
  #           color = "red", 
  #           size = 6, nudge_y = 50, nudge_x = 0.5) + # add starts to the significant columns
  NULL
# ggsave(filename = "ccf_rt.pdf", plot_ccf_rt, width = 8, height = 6)
plot_ccf_rt
```

```{r}
plot_ccf_rt_fi <- contrast(emm_ccf_rt, "pairwise", by="Congruency") %>% 
  summary(infer=TRUE) %>% 
  as_tibble() %>% 
  mutate(Congruency = fct_recode(Congruency, congruent="con", incongruent="inc")) %>% 
  ggplot(aes(y = estimate, x = Congruency, color = Congruency)) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), size=1.5, width=0, 
                alpha = .6) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_color_manual(values=two_colors) +
  # coord_cartesian(ylim = ylimit_cf_fi_d) +  # set the limit for y axis c(0, 1100)
  labs(x = "Congruency", y = "Correct response times (ms)") +  # set the names for main, x and y axises
  theme(legend.position = "none") +
  NULL
# ggsave(filename = "ccf_rt_fi.pdf", plot_ccf_rt_fi, width = 8, height = 6)
plot_ccf_rt_fi
```


## Facilitation and interference in the complete composite face task

### Sensitivity d'

#### Maximal model
```{r}
# thisfile <- here("jubail", "lmm_fi_d_max.rds")
# 
# if (file.exists(thisfile)) {
#   lmm_fi_d_max <- readRDS(thisfile)
#   
# } else {
#   
#   lmm_fi_d_max <-
#     glmer(isSame ~ Congruency * SD + Cue +
#             (Congruency * SD | Subject) +
#             (Congruency * SD | StimGroup),
#           df_fi,
#           family = binomial(link = "probit"),
#           control = glmerControl(optCtrl = list(maxfun = 1e7)))
#   
#   saveRDS(lmm_fi_d_max, thisfile)
# }
# 
# summary(lmm_fi_d_max)
```

#### Zero-correlation-parameter model
```{r}
thisfile <- here("jubail", "lmm_fi_d_zcp.rds")

if (file.exists(thisfile)) {
  lmm_fi_d_zcp <- readRDS(thisfile)
  
} else {
  
  lmm_fi_d_zcp <- 
    glmer(isSame ~ Congruency * SD + Cue +
            (ConInc + IncIso + SD_C + 
               ConInc_SD + IncIso_SD || Subject) +
            (ConInc + IncIso + SD_C + 
               ConInc_SD + IncIso_SD || StimGroup),
          df_fi,
          family = binomial(link = "probit"),
          control = glmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_fi_d_zcp, thisfile)
}

summary(lmm_fi_d_zcp)
```

```{r}
summary(rePCA(lmm_fi_d_zcp))
```

#### Extended model
```{r}
thisfile <- here("jubail", "lmm_fi_d_etd.rds")

if (file.exists(thisfile)) {
  lmm_fi_d_etd <- readRDS(thisfile)
  
} else {
  
  lmm_fi_d_etd <- 
    glmer(isSame ~ Congruency * SD + Cue +
            (ConInc + IncIso + SD_C + 
               ConInc_SD + IncIso_SD | Subject) +
            (ConInc + IncIso + SD_C + 
               ConInc_SD + IncIso_SD | StimGroup),
          df_fi,
          family = binomial(link = "probit"),
          control = glmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_fi_d_etd, thisfile)
}

summary(lmm_fi_d_etd)
```

```{r}
summary(rePCA(lmm_fi_d_etd))
```

By-subject `ConInc`, `IncIso`, by-item `(Intercept)`, `ConInc`, and `IncIso` were removed.

```{r}
thisfile <- here("jubail", "lmm_fi_d_etd2.rds")

if (file.exists(thisfile)) {
  lmm_fi_d_etd2 <- readRDS(thisfile)
  
} else {
  
  lmm_fi_d_etd2 <-
    glmer(isSame ~ Congruency * SD + Cue +
            (SD_C + # ConInc + IncIso +
               ConInc_SD + IncIso_SD | Subject) +
            (0 + SD_C + # ConInc + IncIso +
               ConInc_SD + IncIso_SD | StimGroup),
          df_fi,
          family = binomial(link = "probit"),
          control = glmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_fi_d_etd2, thisfile)
}

summary(lmm_fi_d_etd2)
```

```{r}
summary(rePCA(lmm_fi_d_etd2))
```

By-subject `(Intercept)` and by-item `IncIso_SD` were removed.

```{r}
thisfile <- here("jubail", "lmm_fi_d_etd3.rds")

if (file.exists(thisfile)) {
  
  lmm_fi_d_etd3 <- readRDS(thisfile)
  
} else {
  lmm_fi_d_etd3 <-
    glmer(isSame ~ Congruency * SD + Cue +
            (0 + SD_C + # ConInc + IncIso +
               ConInc_SD + IncIso_SD | Subject) +
            (0 + SD_C + # ConInc + IncIso +
               ConInc_SD | StimGroup), # + IncIso_SD
          df_fi,
          family = binomial(link = "probit"),
          control = glmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_fi_d_etd3, thisfile)
}

summary(lmm_fi_d_etd3)
```

```{r}
summary(rePCA(lmm_fi_d_etd3))
```

#### Optimal model
```{r}
anova(lmm_fi_d_zcp, lmm_fi_d_etd3, refit=FALSE)
```

`lmm_fi_d_zcp` is used as the optimal model.
```{r}
lmm_fi_d_opt <- lmm_fi_d_zcp
```

#### Effects of interest
Hit and false alarm in each condition:
```{r}
(emm_fi_probit <- emmeans(lmm_fi_d_opt, ~ Congruency + SD, type = "response"))
```

Sensitivity d' in each condition:
```{r}
emm_fi_d <- contrast(emm_fi_probit, "pairwise", simple="SD")
summary(emm_fi_d[1:3], infer=TRUE)
```

Plot of d':
```{r}
emmip(emm_fi_d, ~ Congruency, CIs = TRUE)
```

Facilitation in d':
```{r}
emm_fie_d <- contrast(emm_fi_probit, interaction="pairwise")
summary(emm_fie_d[2], side=">", infer=TRUE)
```

Interference in d':
```{r}
summary(emm_fie_d[3], side="<", infer=TRUE)
```


#### Plot

```{r }
fi_colors <- c("con" = two_colors[1], "inc" = two_colors[2], "iso" = "black")
fi_linetype <- c("con" = "solid", "inc" = "dashed", "iso" = "solid")

plot_fi_d <- emm_fi_d %>%
  summary(infer=TRUE) %>% 
  as_tibble() %>% 
  mutate(Alignment = if_else(Congruency=="iso", "iso", "ali"),
         group_ai = if_else(Congruency=="inc", "NULL", "ai"),
         group_ii = if_else(Congruency=="con", "NULL", "ii")) %>%
  mutate(Alignment = fct_recode(Alignment, aligned="ali", isolated="iso")) %>%
  ggplot(aes(Alignment, estimate, color=Congruency, linetype=Congruency)) +
  geom_point(size = 2) + # position = position_dodge(width = 0.1),
  geom_line(aes(group=group_ai, color="con", linetype="con"), size = 0.8) +
  geom_line(aes(group=group_ii, color="inc", linetype="inc"), size = 0.8) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), size=1.5, width=0, 
                alpha = .6, # position = position_dodge(width = 0.1),
                linetype = "solid",
                show.legend = F) + 
  scale_color_manual(values=fi_colors, 
                     breaks = c("con", "inc"),
                     labels = c("Facilitation", "Interference", NULL)) +
  scale_linetype_manual(values = fi_linetype,
                     breaks = c("con", "inc"),
                     labels = c("Facilitation", "Interference", NULL)) +
  coord_cartesian(ylim = c(0,3.2)) +  # set the limit for y axis c(0, 1100)
  labs(y = expression("Sensitivity"~italic("d'")), color=NULL, linetype=NULL) +  # set the names for main, x and y axises
  # geom_text(label = c("***", "***", ""),
  #           color = "red",
  #           size = 6, nudge_y = c(0.5, -0.5, 0), nudge_x = 0.5) + # add starts to the significant columns
  NULL
# ggsave(filename = "fi_d.pdf", plot_fi_d, width = 8, height = 6)
plot_fi_d
```

### Correct response times

#### Maximal model
```{r}
# thisfile <- here("jubail", "lmm_fi_rt_max.rds")
# 
# if (file.exists(thisfile)) {
#   lmm_fi_rt_max <- readRDS(thisfile)
# 
# } else {
#   
#   lmm_fi_rt_max <-
#     lmer(log(RT) ~ Congruency + SD + Cue +
#            (Congruency | Subject) +
#            (Congruency | StimGroup),
#          filter(df_fi, Correct),
#          control = lmerControl(optCtrl = list(maxfun = 1e7)))
#   
#   saveRDS(lmm_fi_rt_max, thisfile)
# }
# 
# summary(lmm_fi_rt_max)
```

#### Zero-correlation-parameter model
```{r}
thisfile <- here("jubail", "lmm_fi_rt_zcp.rds")

if (file.exists(thisfile)) {
  lmm_fi_rt_zcp <- readRDS(thisfile)
  
} else {
  
  lmm_fi_rt_zcp <- 
    lmer(log(RT) ~ Congruency + SD + Cue +
           (ConInc + IncIso || Subject) +
           (ConInc + IncIso || StimGroup),
         filter(df_fi, Correct),
         control = lmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_fi_rt_zcp, thisfile)
}

summary(lmm_fi_rt_zcp)
```

```{r}
summary(rePCA(lmm_fi_rt_zcp))
```
No random effects need to be removed. Therefore, we apply the extended model (i.e., the maximal model in this case) directly.

#### Extended model
```{r}
thisfile <- here("jubail", "lmm_fi_rt_etd.rds")

if (file.exists(thisfile)) {
  lmm_fi_rt_etd <- readRDS(thisfile)
  
} else {
  lmm_fi_rt_etd <- 
    lmer(log(RT) ~ Congruency + SD + Cue +
           (ConInc + IncIso | Subject) +
           (ConInc + IncIso | StimGroup),
         filter(df_fi, Correct),
         control = lmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_fi_rt_etd, thisfile)
}

summary(lmm_fi_rt_etd)
```

```{r}
summary(rePCA(lmm_fi_rt_etd))
```
By-item `(Intercept)` was removed.

```{r}
thisfile <- here("jubail", "lmm_fi_rt_etd2.rds")

if (file.exists(thisfile)) {
  lmm_fi_rt_etd2 <- readRDS(thisfile)
  
} else {
  
  lmm_fi_rt_etd2 <- 
    lmer(log(RT) ~ Congruency + SD + Cue +
           (ConInc + IncIso | Subject) +
           (0 + ConInc + IncIso | StimGroup), 
         filter(df_fi, Correct),
         control = lmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_fi_rt_etd2, thisfile)
}

summary(lmm_fi_rt_etd2)
```

```{r}
summary(rePCA(lmm_fi_rt_etd2))
```

By-subject `ConInc` was removed.

```{r}
thisfile <- here("jubail", "lmm_fi_rt_etd3.rds")

if (file.exists(thisfile)) {
  lmm_fi_rt_etd3 <- readRDS(thisfile)
  
} else {
  
  lmm_fi_rt_etd3 <- 
    lmer(log(RT) ~ Congruency + SD + Cue +
           (ConInc + IncIso | Subject) +
           (0 + IncIso | StimGroup), # ConInc + 
         filter(df_fi, Correct),
         control = lmerControl(optCtrl = list(maxfun = 1e7)))
  
  saveRDS(lmm_fi_rt_etd3, thisfile)
}

summary(lmm_fi_rt_etd3)
```

#### Optimal model
```{r}
anova(lmm_fi_rt_zcp, lmm_fi_rt_etd3, refit=FALSE)
```

`lmm_fi_rt_etd3` is used as the optimal model.
```{r}
lmm_fi_rt_opt <- lmm_fi_rt_etd3
```

#### Effects of interest
Correct RT for each condition:
```{r}
emm_fi_rt <- emmeans(lmm_fi_rt_opt, ~ Congruency)
summary(emm_fi_rt, type = "response")
```

Plot of each condition:
```{r}
emmip(emm_fi_rt,  ~ Congruency, CIs = TRUE, type = "response") 
```

Facilitation in RT (differences of log RT):
```{r}
emm_fie_rt <- contrast(emm_fi_rt, "pairwise")
summary(emm_fie_rt[2], side="<", infer=TRUE)
```

Facilitation in RT (ratio of RT):
```{r}
summary(emm_fie_rt[2], side="<", infer=TRUE, type="response") # exp(0.038)
```

Interference in RT (differences of log RT):
```{r}
summary(emm_fie_rt[3], side=">", infer=TRUE) 
```

Interference in RT (ratio of RT):
```{r}
summary(emm_fie_rt[3], side=">", infer=TRUE, type="response") # exp(0.0976)
```

#### Plot

```{r }
fi_colors <- c("con" = two_colors[1], "inc" = two_colors[2], "iso" = "black")
fi_linetype <- c("con" = "solid", "inc" = "dashed", "iso" = "solid")

plot_fi_rt <- emm_fi_rt %>% 
  summary(type = "response") %>% 
  as_tibble() %>% 
  mutate(Alignment = if_else(Congruency=="iso", "iso", "ali"),
         group_ai = if_else(Congruency=="inc", "NULL", "ai"),
         group_ii = if_else(Congruency=="con", "NULL", "ii")) %>%
  mutate(Alignment = fct_recode(Alignment, aligned="ali", isolated="iso")) %>%
  ggplot(aes(y = response, x = Alignment, color=Congruency, linetype=Congruency)) +
  geom_point(size = 2) + # position = position_dodge(width = 0.1), color=c(two_colors, "black")
  geom_line(aes(group=group_ai, color="con", linetype="con"), size = 0.8) +
  geom_line(aes(group=group_ii, color="inc", linetype="inc"), size = 0.8) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), size=1.5, width=0, 
                alpha = .6, # position = position_dodge(width = 0.1),
                linetype = "solid",
                show.legend = F) + 
  scale_color_manual(values=fi_colors, 
                     breaks = c("con", "inc"),
                     labels = c("Facilitation", "Interference", NULL)) +
  scale_linetype_manual(values = fi_linetype,
                     breaks = c("con", "inc"),
                     labels = c("Facilitation", "Interference", NULL)) +
  coord_cartesian(ylim = c(800, 1000)) +  # set the limit for y axis c(0, 1100)
  labs(y = "Correct response times (ms)", color=NULL, linetype=NULL) +  # set the names for main, x and y axises
  # geom_text(label = c("***", "***", ""),
  #           color = "red",
  #           size = 6, nudge_y = c(-50, 20, 0), nudge_x = 0.5) + # add starts to the significant columns
  NULL
# ggsave(filename = "fi_rt.pdf", plot_fi_rt, width = 8, height = 6)
plot_fi_rt
```

## Figures

### Figure 2: holsitic processing effects

```{r}
acc_y_limits <- c(.75, 1)
d_y_limits <- c(0, 2.7)
d_y_breaks <- seq(0, 2.5, .5)
rt_y_limits <- c(550, 1450)
rt_y_breaks <- seq(600, 1400, 200)

plot_pw_acc_pub <- plot_pw_acc + 
  coord_cartesian(ylim = acc_y_limits) 

plot_pw_rt_pub <- plot_pw_rt +
  scale_y_continuous(breaks=rt_y_breaks) +
  coord_cartesian(ylim = rt_y_limits) 
  
plot_scf_acc_pub <- plot_scf_acc +
  coord_cartesian(ylim = acc_y_limits) 

plot_scf_rt_pub <- plot_scf_rt +
  scale_y_continuous(breaks=rt_y_breaks) +
  coord_cartesian(ylim = rt_y_limits) 

plot_ccf_d_pub <- plot_ccf_d +
  coord_cartesian(ylim = d_y_limits) +
  scale_y_continuous(breaks=d_y_breaks) +
  theme(legend.position = c(.7, .2),
        legend.box = "horizontal") 

plot_ccf_rt_pub <- plot_ccf_rt +
  scale_y_continuous(breaks=rt_y_breaks) +
  coord_cartesian(ylim = rt_y_limits) +
  theme(legend.position = "none")

plot_fi_d_pub <- plot_fi_d +
  coord_cartesian(ylim = d_y_limits) +
  scale_y_continuous(breaks=d_y_breaks) +
  theme(legend.position = c(.7, .2),
        legend.box = "horizontal") 

plot_fi_rt_pub <- plot_fi_rt +
  scale_y_continuous(breaks=rt_y_breaks) +
  coord_cartesian(ylim = rt_y_limits) +
  theme(legend.position = "none")
```

```{r fig.width=5.5, fig.asp=.65}
fig_hp_iso <- 
  ggarrange(ggarrange(plot_pw_acc_pub, plot_pw_rt_pub) %>% 
              annotate_figure(top = text_grob("Part-whole task", 
                                              face="bold", size = 14)),
            ggplot() + theme_void(), 
            ggarrange(plot_scf_acc_pub, plot_scf_rt_pub) %>% 
              annotate_figure(top = text_grob("Standard composite face task", 
                                              face="bold", size = 14)),
            ggplot() + theme_void(), ggplot() + theme_void(), ggplot() + theme_void(), 
            ggarrange(plot_ccf_d_pub, plot_ccf_rt_pub) %>% 
              annotate_figure(top = text_grob("Complete composite face task", 
                                              face="bold", size = 14)),
            ggplot() + theme_void(), 
            ggarrange(plot_fi_d_pub, plot_fi_rt_pub) %>% 
              annotate_figure(top = text_grob("Facilitation and interference effects", 
                                              face="bold", size = 14)),
            labels = c("a", "", "b", "", "", "", "c", "", "d"),
            widths = c(1, 0.05, 1),
            heights = c(1, 0.05, 1),
            nrow=3, ncol=3) +
  bgcolor("white") +
  border("white")
# ggsave(filename = here("figures","fig_hp_iso.pdf"), fig_hp_iso, width = 14, height = 14*.65)
# fig_hp_iso
```

```{r fig.width=13}
fig_hp_iso
```


```{r}
plot_ccf_d_fi_pub <- plot_ccf_d_fi 
plot_ccf_rt_fi_pub <- plot_ccf_rt_fi 
```

```{r fig.width=5.5, fig.asp=.65}
fig_hp <- 
  ggarrange(ggarrange(plot_pw_acc_pub, plot_pw_rt_pub) %>% 
              annotate_figure(top = text_grob("Part-whole task", 
                                              face="bold", size = 14)),
            ggplot() + theme_void(), 
            ggarrange(plot_scf_acc_pub, plot_scf_rt_pub) %>% 
              annotate_figure(top = text_grob("Standard composite face task", 
                                              face="bold", size = 14)),
            ggplot() + theme_void(), ggplot() + theme_void(), ggplot() + theme_void(), 
            ggarrange(plot_ccf_d_pub, plot_ccf_rt_pub) %>% 
              annotate_figure(top = text_grob("Complete composite face task", 
                                              face="bold", size = 14)),
            ggplot() + theme_void(), 
            ggarrange(plot_ccf_d_fi_pub, plot_ccf_rt_fi_pub) %>% 
              annotate_figure(top = text_grob("Facilitation and interference effects", 
                                              face="bold", size = 14)),
            labels = c("a", "", "b", "", "", "", "c", "", "d"),
            widths = c(1, 0.05, 1),
            heights = c(1, 0.05, 1),
            nrow=3, ncol=3) +
  bgcolor("white") +
  border("white")
# ggsave(filename = here("figures","fig_hp.pdf"), fig_hp, width = 14, height = 14*.65)
# fig_hp
```

```{r fig.width=13}
fig_hp
```

```{r}
# save png
# ggsave(filename = here("figures","fig_hp_iso.png"), fig_hp_iso, width = 14, height = 14*.65)
# ggsave(filename = here("figures","fig_hp.png"), fig_hp, width = 14, height = 14*.65)
```

