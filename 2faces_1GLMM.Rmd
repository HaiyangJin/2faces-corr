
# Holistic processing effects

Linear mixed-effects models are used to examine the holistic processing effects in the part-whole, standard composite face task, and complete composite face task.

## Steps to obtain the optimal model

1. If the maximal model did not converge, correlations between random effects were removed, making the zero-correlation-parameter (ZCP) model. 
2. Principal component analysis implemented with `rePCA()` function was then used to identify random effects that explained less than 0.1% of the total variances; they were removed from the ZCP model to make the reduced model. 
3. The extended model was built by adding back the correlations between random effects in the reduced model. 
4. If the extended model did not converge, the random effects that explained less than 1% of total variances were identified by `rePCA()` and removed to make the updated extended model; this step was iterated until an extended model converged. 
5. The converged extended model was then compared to the reduced model via `anova()` function and the model that explained the data better (with smaller Bayesian Information Criterion) was used as the optimal model. 
6. All follow-up analyses were performed on the optimal model. 

## Part-whole task

### Accuracy 

#### Maximal model

```{r}
# thisfile <- here("jubail", "lmm_pw_acc_max.rds")
# 
# if (file.exists(thisfile)) {
#   
#   lmm_pw_acc_max <- readRDS(thisfile)
#   
# } else {
#   lmm_pw_acc_max <- 
#     glmer(Correct ~ PW * Feature + 
#             (PW * Feature | Subject) +
#             (PW * Feature | StimGroup),
#           df_pw,
#           family = binomial(link = "logit"),
#           control = glmerControl(optimizer = "optimx", 
#                                  optCtrl = list(method = "nlminb", 
#                                                 starttests = FALSE, 
#                                                 kkt = FALSE)))
#   saveRDS(lmm_pw_acc_max, thisfile)
# }
# 
# summary(lmm_pw_acc_max)
```

#### Zero-correlation-parameter model

```{r}
thisfile <- here("jubail", "lmm_pw_acc_zcp.rds")

if (file.exists(thisfile)) {
  
  lmm_pw_acc_zcp <- readRDS(thisfile)
  
} else {
  lmm_pw_acc_zcp <- 
    glmer(Correct ~ PW * Feature + 
            (PW_C + Feature_C + PW_Feature || Subject) +
            (PW_C + Feature_C + PW_Feature || StimGroup),
          df_pw,
          family = binomial(link = "logit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  saveRDS(lmm_pw_acc_zcp, thisfile)
}

summary(lmm_pw_acc_zcp)
```

```{r}
summary(rePCA(lmm_pw_acc_zcp))
```
`(PW_Feature | Subject)` will be removed.

#### Reduced model

```{r}
thisfile <- here("jubail", "lmm_pw_acc_rdc.rds")

if (file.exists(thisfile)) {
  
  lmm_pw_acc_rdc <- readRDS(thisfile)
  
} else {
  lmm_pw_acc_rdc <- 
    glmer(Correct ~ PW * Feature + 
            (PW_C + Feature_C || Subject) +
            (PW_C + Feature_C + PW_Feature || StimGroup),
          df_pw,
          family = binomial(link = "logit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  saveRDS(lmm_pw_acc_rdc, thisfile)
}

summary(lmm_pw_acc_rdc)
```

#### Extended model

```{r}
thisfile <- here("jubail", "lmm_pw_acc_etd.rds")

if (file.exists(thisfile)) {
  
  lmm_pw_acc_etd <- readRDS(thisfile)
  
} else {
  lmm_pw_acc_etd <- 
    glmer(Correct ~ PW * Feature + 
            (PW_C + Feature_C | Subject) +
            (PW_C + Feature_C + PW_Feature | StimGroup),
          df_pw,
          family = binomial(link = "logit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  saveRDS(lmm_pw_acc_etd, thisfile)
}

summary(lmm_pw_acc_etd)
```

#### Optimal model

```{r}
anova(lmm_pw_acc_rdc, lmm_pw_acc_etd)
```

`lmm_pw_acc_etd` will be used as the optimal model.
```{r}
lmm_pw_acc_opt <- lmm_pw_acc_etd
```

#### Effects of interest
```{r}
emm_pw_acc <- emmeans(lmm_pw_acc_opt, ~ PW + Feature, type = "response")
emm_pw_acc
```

```{r}
contrast(emmeans(lmm_pw_acc_opt, ~ PW), "pairwise")
```

```{r}
contrast(emmeans(lmm_pw_acc_opt, ~ PW), "pairwise", type="response")
```

```{r message=FALSE}
emmip(lmm_pw_acc_opt, ~ PW, CIs = TRUE, type = "response") 
```

```{r}
contrast(emmeans(lmm_pw_acc_opt, ~ PW | Feature), "pairwise")
```


```{r}
emmip(lmm_pw_acc_opt, ~ PW | Feature, CIs = TRUE, type = "response") 
```

### Correct response times

#### Maximal model

```{r}
# thisfile <- here("jubail", "lmm_pw_rt_max.rds")
# 
# if (file.exists(thisfile)) {
#   
#   lmm_pw_rt_max <- readRDS(thisfile)
#   
# } else {
#   lmm_pw_rt_max <- 
#     lmer(log(RT) ~ PW * Feature + 
#            (PW * Feature | Subject) +
#            (PW * Feature | StimGroup),
#          filter(df_pw, Correct),
#          control = lmerControl(optimizer = "optimx", 
#                                optCtrl = list(method = "nlminb", 
#                                               starttests = FALSE, 
#                                               kkt = FALSE)))
#   saveRDS(lmm_pw_rt_max, thisfile)
# }
# 
# summary(lmm_pw_rt_max)
```

#### Zero-correlation-parameter model

```{r}
thisfile <- here("jubail", "lmm_pw_rt_zcp.rds")

if (file.exists(thisfile)) {
  
  lmm_pw_rt_zcp <- readRDS(thisfile)
  
} else {
  lmm_pw_rt_zcp <- 
    lmer(log(RT) ~ PW * Feature + 
           (PW_C + Feature_C + PW_Feature || Subject) +
           (PW_C + Feature_C + PW_Feature || StimGroup),
         filter(df_pw, Correct),
         control = lmerControl(optimizer = "optimx", 
                               optCtrl = list(method = "nlminb", 
                                              starttests = FALSE, 
                                              kkt = FALSE)))
  saveRDS(lmm_pw_rt_zcp, thisfile)
}

summary(lmm_pw_rt_zcp)
```

```{r}
summary(rePCA(lmm_pw_rt_zcp))
```
No random effects need to be removed. Therefore, we apply the extended model (i.e., the maximal model in this case) directly.

#### Extended model

```{r}
thisfile <- here("jubail", "lmm_pw_rt_etd.rds")

if (file.exists(thisfile)) {
  
  lmm_pw_rt_etd <- readRDS(thisfile)
  
} else {
  lmm_pw_rt_etd <- 
    lmer(log(RT) ~ PW * Feature + 
           (PW_C + Feature_C + PW_Feature | Subject) +
           (PW_C + Feature_C + PW_Feature | StimGroup),
         filter(df_pw, Correct),
         control = lmerControl(optimizer = "optimx", 
                               optCtrl = list(method = "nlminb", 
                                              starttests = FALSE, 
                                              kkt = FALSE)))
  saveRDS(lmm_pw_rt_etd, thisfile)
}

summary(lmm_pw_rt_etd)
```

```{r}
summary(rePCA(lmm_pw_rt_etd))
```

#### Optimal model

```{r}
anova(lmm_pw_rt_zcp, lmm_pw_rt_etd, refit=FALSE)
```

Use `lmm_pw_rt_etd` as the optimal model.
```{r}
lmm_pw_rt_opt <- lmm_pw_rt_etd
```

#### Effects of interest
```{r}
(emm_pw_rt <- emmeans(lmm_pw_rt_opt, ~ PW + Feature))
```

```{r}
contrast(emmeans(lmm_pw_rt_opt, ~ PW), "pairwise")
```

```{r}
contrast(emmeans(lmm_pw_rt_opt, ~ PW), "pairwise", type = "response")
```

```{r}
contrast(emmeans(lmm_pw_rt_opt, ~ PW | Feature), "pairwise")
```


```{r}
emmip(lmm_pw_rt_opt, ~ PW | Feature, CIs = TRUE, type = "response") 
```


## Standard composite face task

### Accuracy 


#### Maximal model
```{r}
thisfile <- file.path("jubail", "lmm_scf_acc_max.rds")

if (file.exists(thisfile)) {
  
  lmm_scf_acc_max <- readRDS(thisfile)
  
} else {
  lmm_scf_acc_max <- glmer(Correct ~ Alignment + 
                             (Alignment | Subject) +
                             (Alignment | StimGroup),
                           df_scf,
                           family = binomial(link = "logit"),
                           control = glmerControl(optimizer = "optimx", 
                                                  optCtrl = list(method = "nlminb", 
                                                                 starttests = FALSE, 
                                                                 kkt = FALSE)))
  saveRDS(lmm_scf_acc_max, thisfile)
}

summary(lmm_scf_acc_max)
```

#### Zero-correlation-parameter model

```{r}
thisfile <- file.path("jubail", "lmm_scf_acc_zcp.rds")

if (file.exists(thisfile)) {
  
  lmm_scf_acc_zcp <- readRDS(thisfile)
  
} else {
  lmm_scf_acc_zcp <- glmer(Correct ~ Alignment + 
                             (Ali_C | Subject) +
                             (Ali_C | StimGroup),
                           df_scf,
                           family = binomial(link = "logit"),
                           control = glmerControl(optimizer = "optimx", 
                                                  optCtrl = list(method = "nlminb", 
                                                                 starttests = FALSE, 
                                                                 kkt = FALSE)))
  saveRDS(lmm_scf_acc_zcp, thisfile)
}

summary(lmm_scf_acc_zcp)
```

#### Optimal model

```{r}
lmm_scf_acc_opt <- lmm_scf_acc_max
```

#### Effects of interest
```{r}
emm_scf_acc <- emmeans(lmm_scf_acc_opt, ~ Alignment, type="response")
emm_scf_acc
```

```{r}
contrast(emmeans(lmm_scf_acc_opt, ~ Alignment), "pairwise")
```


```{r}
emmip(lmm_scf_acc_opt, ~ Alignment, CIs = TRUE, type = "response") 
```



### Correct response times

#### Maximal model
```{r}
thisfile <- file.path("jubail", "lmm_scf_rt_max.rds")

if (file.exists(thisfile)) {
  
  lmm_scf_rt_max <- readRDS(thisfile)
  
} else {
  lmm_scf_rt_max <- lmer(log(RT) ~ Alignment + 
                           (Alignment | Subject) +
                           (Alignment | StimGroup),
                         filter(df_scf, Correct),
                         control = lmerControl(optimizer = "optimx", 
                                               optCtrl = list(method = "nlminb", 
                                                              starttests = FALSE, 
                                                              kkt = FALSE)))
  saveRDS(lmm_scf_rt_max, thisfile)
}

summary(lmm_scf_rt_max)
```

#### Optimal model
```{r}
lmm_scf_rt_opt <- lmm_scf_rt_max
```


#### Effects of interest
```{r}
emm_scf_rt <- emmeans(lmm_scf_rt_opt, ~ Alignment, type = "response")
emm_scf_rt
```

```{r}
contrast(emmeans(lmm_scf_rt_opt, ~ Alignment), "pairwise")
```

```{r}
contrast(emmeans(lmm_scf_rt_opt, ~ Alignment), "pairwise", type = "response")
```


```{r}
emmip(lmm_scf_rt_opt, ~ Alignment, CIs = TRUE, type = "response") 
```


## Complete composite face task

### Sensitivity d'

#### Maximal model
```{r}
thisfile <- file.path("jubail", "lmm_ccf_d_max.rds")

if (file.exists(thisfile)) {
  
  lmm_ccf_d_max <- readRDS(thisfile)
  
} else {
  lmm_ccf_d_max <- glmer(isSame ~ Congruency * Alignment * SD + Cue +
                           (Congruency * Alignment * SD | Subject) +
                           (Congruency * Alignment * SD | StimGroup),
                         df_ccf,
                         family = binomial(link = "probit"),
                         control = glmerControl(optimizer = "optimx", 
                                                optCtrl = list(method = "nlminb", 
                                                               starttests = FALSE, 
                                                               kkt = FALSE)))
  saveRDS(lmm_ccf_d_max, thisfile)
}

summary(lmm_ccf_d_max)
```

#### Optimal model
```{r}
lmm_ccf_d_opt <- lmm_ccf_d_max
```

#### Effects of interest
```{r}
(emm_ccf_probit <- emmeans(lmm_ccf_d_opt, ~ Congruency + Alignment + SD, type = "response"))
```


```{r}
emm_ccf_d <- contrast(emm_ccf_probit, "pairwise", simple="SD")
emm_ccf_d[1:4]
```

```{r}
cong_emm <- contrast(emm_ccf_probit, interaction="pairwise", by="Alignment")
cong_emm[2]
```

```{r}
contrast(emm_ccf_probit, interaction="pairwise")
```


```{r}
emmip(emm_ccf_d, Congruency ~ Alignment, CIs = TRUE)
```


### Correct response times

#### Maximal model
```{r}
thisfile <- file.path("jubail", "lmm_ccf_rt_max.rds")

if (file.exists(thisfile)) {
  
  lmm_ccf_rt_max <- readRDS(thisfile)
  
} else {
  lmm_ccf_rt_max <- lmer(log(RT) ~ Congruency * Alignment + SD + Cue + 
                           (Congruency * Alignment | Subject) +
                           (Congruency * Alignment | StimGroup),
                         filter(df_ccf, Correct),
                         control = lmerControl(optimizer = "optimx", 
                                               optCtrl = list(method = "nlminb", 
                                                              starttests = FALSE, 
                                                              kkt = FALSE)))
  saveRDS(lmm_ccf_rt_max, thisfile)
}

summary(lmm_ccf_rt_max)
```

#### Optimal model
```{r}
lmm_ccf_rt_opt <- lmm_ccf_rt_max
```

#### Effects of interest
```{r}
thisfile <- file.path("jubail", "emm_ccf_rt.rds")

if (file.exists(thisfile)) {
  
  emm_ccf_rt <- readRDS(thisfile)
  
} else {
  emm_ccf_rt <- emmeans(lmm_ccf_rt_opt, ~ Congruency + Alignment, type = "response",
                        lmerTest.limit = 6400,
                        pbkrtest.limit = 6400)
  
  saveRDS(emm_ccf_rt, thisfile)
}

emm_ccf_rt
```

```{r}
contrast(emm_ccf_rt, interaction="pairwise")
```

```{r}
contrast(emm_ccf_rt, interaction="pairwise", type = "response")
```


```{r}
emmip(emm_ccf_rt, Congruency ~ Alignment, CIs = TRUE, type = "response") 
```



## Facilitation and interference in the complete composite face task

### Sensitivity d'

#### Maximal model
```{r}
thisfile <- file.path("jubail", "lmm_fi_d_max.rds")

if (file.exists(thisfile)) {
  
  lmm_fi_d_max <- readRDS(thisfile)
  
} else {
  lmm_fi_d_max <- glmer(isSame ~ Congruency * SD + Cue +
                           (Congruency * SD | Subject) +
                           (Congruency * SD | StimGroup),
                         df_fi,
                         family = binomial(link = "probit"),
                         control = glmerControl(optimizer = "optimx", 
                                                optCtrl = list(method = "nlminb", 
                                                               starttests = FALSE, 
                                                               kkt = FALSE)))
  saveRDS(lmm_fi_d_max, thisfile)
}

summary(lmm_fi_d_max)
```

#### Optimal model
```{r}
lmm_fi_d_opt <- lmm_fi_d_max
```

#### Effects of interest
```{r}
(emm_fi_probit <- emmeans(lmm_fi_d_opt, ~ Congruency + SD, type = "response"))
```


```{r}
emm_fi_d <- contrast(emm_fi_probit, "pairwise", simple="SD")
emm_fi_d[1:3]
```

```{r}
cong_emm <- contrast(emm_fi_probit, interaction="pairwise")
cong_emm[2:3]
```


```{r}
emmip(emm_fi_d, ~ Congruency, CIs = TRUE)
```


### Correct response times

#### Maximal model
```{r}
thisfile <- file.path("jubail", "lmm_fi_rt_max.rds")

if (file.exists(thisfile)) {
  
  lmm_fi_rt_max <- readRDS(thisfile)
  
} else {
  lmm_fi_rt_max <- lmer(log(RT) ~ Congruency + SD + Cue +
                           (Congruency | Subject) +
                           (Congruency | StimGroup),
                         filter(df_fi, Correct),
                         control = lmerControl(optimizer = "optimx", 
                                               optCtrl = list(method = "nlminb", 
                                                              starttests = FALSE, 
                                                              kkt = FALSE)))
  saveRDS(lmm_fi_rt_max, thisfile)
}

summary(lmm_fi_rt_max)
```

#### Optimal model
```{r}
lmm_fi_rt_opt <- lmm_fi_rt_max
```

#### Effects of interest
```{r}
thisfile <- file.path("jubail", "emm_fi_rt.rds")

if (file.exists(thisfile)) {
  
  emm_fi_rt <- readRDS(thisfile)
  
} else {
  emm_fi_rt <- emmeans(lmm_fi_rt_opt, ~ Congruency, type = "response",
                        lmerTest.limit = 6400,
                        pbkrtest.limit = 6400)
  
  saveRDS(emm_fi_rt, thisfile)
}

emm_fi_rt
```

```{r}
contrast(emm_fi_rt, "pairwise")[c(2,3)]
```

```{r}
contrast(emm_fi_rt, "pairwise", type = "response")
```


```{r}
emmip(emm_fi_rt,  ~ Congruency, CIs = TRUE, type = "response") 
```

