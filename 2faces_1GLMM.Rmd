
# Holistic processing effects

Linear mixed-effects models are used to examine the holistic processing effects in the part-whole, standard composite face task, and complete composite face task.

## Steps to obtain the optimal model

1. If the maximal model did not converge, correlations between random effects were removed, making the zero-correlation-parameter (ZCP) model. 
2. Principal component analysis implemented with `rePCA()` function was then used to identify random effects that explained less than 0.1% of the total variances; they were removed from the ZCP model to make the reduced model. 
3. The extended model was built by adding back the correlations between random effects in the reduced model. 
4. If the extended model did not converge, the random effects that explained less than 1% of total variances were identified by `rePCA()` and removed to make the updated extended model; this step was iterated until an extended model converged. 
5. The converged extended model was then compared to the reduced model via `anova()` function and the model that explained the data better (with smaller Bayesian Information Criterion) was used as the optimal model. 
6. All follow-up analyses were performed on the optimal model. 

## Part-whole task

### Accuracy 

#### Maximal model

```{r}
# thisfile <- here("jubail", "lmm_pw_acc_max.rds")
# 
# if (file.exists(thisfile)) {
#   
#   lmm_pw_acc_max <- readRDS(thisfile)
#   
# } else {
#   lmm_pw_acc_max <- 
#     glmer(Correct ~ PW * Feature + 
#             (PW * Feature | Subject) +
#             (PW * Feature | StimGroup),
#           df_pw,
#           family = binomial(link = "logit"),
#           control = glmerControl(optimizer = "optimx", 
#                                  optCtrl = list(method = "nlminb", 
#                                                 starttests = FALSE, 
#                                                 kkt = FALSE)))
#   saveRDS(lmm_pw_acc_max, thisfile)
# }
# 
# summary(lmm_pw_acc_max)
```

#### Zero-correlation-parameter model

```{r}
thisfile <- here("jubail", "lmm_pw_acc_zcp.rds")

if (file.exists(thisfile)) {
  
  lmm_pw_acc_zcp <- readRDS(thisfile)
  
} else {
  lmm_pw_acc_zcp <- 
    glmer(Correct ~ PW * Feature + 
            (PW_C + Feature_C + PW_Feature || Subject) +
            (PW_C + Feature_C + PW_Feature || StimGroup),
          df_pw,
          family = binomial(link = "logit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  saveRDS(lmm_pw_acc_zcp, thisfile)
}

summary(lmm_pw_acc_zcp)
```

```{r}
summary(rePCA(lmm_pw_acc_zcp))
```
`(PW_Feature | Subject)` will be removed.

#### Reduced model

```{r}
thisfile <- here("jubail", "lmm_pw_acc_rdc.rds")

if (file.exists(thisfile)) {
  
  lmm_pw_acc_rdc <- readRDS(thisfile)
  
} else {
  lmm_pw_acc_rdc <- 
    glmer(Correct ~ PW * Feature + 
            (PW_C + Feature_C || Subject) +
            (PW_C + Feature_C + PW_Feature || StimGroup),
          df_pw,
          family = binomial(link = "logit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  saveRDS(lmm_pw_acc_rdc, thisfile)
}

summary(lmm_pw_acc_rdc)
```

#### Extended model

```{r}
thisfile <- here("jubail", "lmm_pw_acc_etd.rds")

if (file.exists(thisfile)) {
  
  lmm_pw_acc_etd <- readRDS(thisfile)
  
} else {
  lmm_pw_acc_etd <- 
    glmer(Correct ~ PW * Feature + 
            (PW_C + Feature_C | Subject) +
            (PW_C + Feature_C + PW_Feature | StimGroup),
          df_pw,
          family = binomial(link = "logit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  saveRDS(lmm_pw_acc_etd, thisfile)
}

summary(lmm_pw_acc_etd)
```

#### Optimal model

```{r}
anova(lmm_pw_acc_rdc, lmm_pw_acc_etd)
```

`lmm_pw_acc_etd` will be used as the optimal model.
```{r}
lmm_pw_acc_opt <- lmm_pw_acc_etd
```

#### Effects of interest
```{r}
emm_pw_acc <- emmeans(lmm_pw_acc_opt, ~ PW + Feature, type = "response")
emm_pw_acc
```

```{r}
contrast(emmeans(lmm_pw_acc_opt, ~ PW), "pairwise")
```

```{r}
contrast(emmeans(lmm_pw_acc_opt, ~ PW), "pairwise", type="response")
```

```{r message=FALSE}
emmip(lmm_pw_acc_opt, ~ PW, CIs = TRUE, type = "response") 
```

```{r}
contrast(emmeans(lmm_pw_acc_opt, ~ PW | Feature), "pairwise")
```


```{r}
emmip(lmm_pw_acc_opt, ~ PW | Feature, CIs = TRUE, type = "response") 
```

### Correct response times

#### Maximal model

```{r}
# thisfile <- here("jubail", "lmm_pw_rt_max.rds")
# 
# if (file.exists(thisfile)) {
#   
#   lmm_pw_rt_max <- readRDS(thisfile)
#   
# } else {
#   lmm_pw_rt_max <- 
#     lmer(log(RT) ~ PW * Feature + 
#            (PW * Feature | Subject) +
#            (PW * Feature | StimGroup),
#          filter(df_pw, Correct),
#          control = lmerControl(optimizer = "optimx", 
#                                optCtrl = list(method = "nlminb", 
#                                               starttests = FALSE, 
#                                               kkt = FALSE)))
#   saveRDS(lmm_pw_rt_max, thisfile)
# }
# 
# summary(lmm_pw_rt_max)
```

#### Zero-correlation-parameter model

```{r}
thisfile <- here("jubail", "lmm_pw_rt_zcp.rds")

if (file.exists(thisfile)) {
  
  lmm_pw_rt_zcp <- readRDS(thisfile)
  
} else {
  lmm_pw_rt_zcp <- 
    lmer(log(RT) ~ PW * Feature + 
           (PW_C + Feature_C + PW_Feature || Subject) +
           (PW_C + Feature_C + PW_Feature || StimGroup),
         filter(df_pw, Correct),
         control = lmerControl(optimizer = "optimx", 
                               optCtrl = list(method = "nlminb", 
                                              starttests = FALSE, 
                                              kkt = FALSE)))
  saveRDS(lmm_pw_rt_zcp, thisfile)
}

summary(lmm_pw_rt_zcp)
```

```{r}
summary(rePCA(lmm_pw_rt_zcp))
```
No random effects need to be removed. Therefore, we apply the extended model (i.e., the maximal model in this case) directly.

#### Extended model

```{r}
thisfile <- here("jubail", "lmm_pw_rt_etd.rds")

if (file.exists(thisfile)) {
  
  lmm_pw_rt_etd <- readRDS(thisfile)
  
} else {
  lmm_pw_rt_etd <- 
    lmer(log(RT) ~ PW * Feature + 
           (PW_C + Feature_C + PW_Feature | Subject) +
           (PW_C + Feature_C + PW_Feature | StimGroup),
         filter(df_pw, Correct),
         control = lmerControl(optimizer = "optimx", 
                               optCtrl = list(method = "nlminb", 
                                              starttests = FALSE, 
                                              kkt = FALSE)))
  saveRDS(lmm_pw_rt_etd, thisfile)
}

summary(lmm_pw_rt_etd)
```

```{r}
summary(rePCA(lmm_pw_rt_etd))
```

#### Optimal model

```{r}
anova(lmm_pw_rt_zcp, lmm_pw_rt_etd, refit=FALSE)
```

Use `lmm_pw_rt_etd` as the optimal model.
```{r}
lmm_pw_rt_opt <- lmm_pw_rt_etd
```

#### Effects of interest
```{r}
(emm_pw_rt <- emmeans(lmm_pw_rt_opt, ~ PW + Feature, type="response"))
```

```{r}
contrast(emmeans(lmm_pw_rt_opt, ~ PW), "pairwise")
```

```{r}
contrast(emmeans(lmm_pw_rt_opt, ~ PW), "pairwise", type = "response")
```

```{r}
contrast(emmeans(lmm_pw_rt_opt, ~ PW | Feature), "pairwise")
```


```{r}
emmip(lmm_pw_rt_opt, ~ PW | Feature, CIs = TRUE, type = "response") 
```


## Standard composite face task

### Accuracy 
#### Maximal model
```{r}
# thisfile <- here("jubail", "lmm_scf_acc_max.rds")
# 
# if (file.exists(thisfile)) {
#   
#   lmm_scf_acc_max <- readRDS(thisfile)
#   
# } else {
#   lmm_scf_acc_max <- 
#     glmer(Correct ~ Alignment + 
#             (Alignment | Subject) +
#             (Alignment | StimGroup),
#           df_scf,
#           family = binomial(link = "logit"),
#           control = glmerControl(optimizer = "optimx", 
#                                  optCtrl = list(method = "nlminb", 
#                                                 starttests = FALSE, 
#                                                 kkt = FALSE)))
#   saveRDS(lmm_scf_acc_max, thisfile)
# }
# 
# summary(lmm_scf_acc_max)
```

#### Zero-correlation-parameter model

```{r}
thisfile <- here("jubail", "lmm_scf_acc_zcp.rds")

if (file.exists(thisfile)) {
  
  lmm_scf_acc_zcp <- readRDS(thisfile)
  
} else {
  lmm_scf_acc_zcp <- 
    glmer(Correct ~ Alignment + 
            (Ali_C || Subject) +
            (Ali_C || StimGroup),
          df_scf,
          family = binomial(link = "logit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  saveRDS(lmm_scf_acc_zcp, thisfile)
}

summary(lmm_scf_acc_zcp)
```

```{r}
summary(rePCA(lmm_scf_acc_zcp))
```
No random effects need to be removed. Therefore, we apply the extended model (i.e., the maximal model in this case) directly.

#### Extended model

```{r}
thisfile <- here("jubail", "lmm_scf_acc_etd.rds")

if (file.exists(thisfile)) {
  
  lmm_scf_acc_etd <- readRDS(thisfile)
  
} else {
  lmm_scf_acc_etd <- 
    glmer(Correct ~ Alignment + 
            (Ali_C | Subject) +
            (Ali_C | StimGroup),
          df_scf,
          family = binomial(link = "logit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  saveRDS(lmm_scf_acc_etd, thisfile)
}

summary(lmm_scf_acc_etd)
```

```{r}
summary(rePCA(lmm_scf_acc_etd))
```
By-item `(Intercept)` will be removed.

```{r}
thisfile <- here("jubail", "lmm_scf_acc_etd2.rds")

if (file.exists(thisfile)) {
  
  lmm_scf_acc_etd2 <- readRDS(thisfile)
  
} else {
  lmm_scf_acc_etd2 <- 
    glmer(Correct ~ Alignment + 
            (Ali_C | Subject) +
            (0 + Ali_C | StimGroup),
          df_scf,
          family = binomial(link = "logit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  saveRDS(lmm_scf_acc_etd2, thisfile)
}

summary(lmm_scf_acc_etd2)
```

#### Optimal model

```{r}
anova(lmm_scf_acc_zcp, lmm_scf_acc_etd2, refit=FALSE)
```
`lmm_scf_acc_zcp` will be used as the optimal model.

```{r}
lmm_scf_acc_opt <- lmm_scf_acc_zcp
```

#### Effects of interest
```{r}
(emm_scf_acc <- emmeans(lmm_scf_acc_opt, ~ Alignment, type="response"))
```

```{r}
contrast(emmeans(lmm_scf_acc_opt, ~ Alignment), "pairwise")
```


```{r}
emmip(lmm_scf_acc_opt, ~ Alignment, CIs = TRUE, type = "response") 
```

### Correct response times

#### Maximal model
```{r}
# thisfile <- here("jubail", "lmm_scf_rt_max.rds")
# 
# if (file.exists(thisfile)) {
#   
#   lmm_scf_rt_max <- readRDS(thisfile)
#   
# } else {
#   lmm_scf_rt_max <- 
#     lmer(log(RT) ~ Alignment + 
#            (Alignment | Subject) +
#            (Alignment | StimGroup),
#          filter(df_scf, Correct),
#          control = lmerControl(optimizer = "optimx", 
#                                optCtrl = list(method = "nlminb", 
#                                               starttests = FALSE, 
#                                               kkt = FALSE)))
#   saveRDS(lmm_scf_rt_max, thisfile)
# }
# 
# summary(lmm_scf_rt_max)
```


#### Zero-correlation-parameter model

```{r}
thisfile <- here("jubail", "lmm_scf_rt_zcp.rds")

if (file.exists(thisfile)) {
  
  lmm_scf_rt_zcp <- readRDS(thisfile)
  
} else {
  # lmm_scf_rt_zcp <- 
  #   lmer(log(RT) ~ Alignment + 
  #          (Ali_C || Subject) +
  #          (Ali_C || StimGroup),
  #        filter(df_scf, Correct),
  #        control = lmerControl(optimizer = "optimx", 
  #                              optCtrl = list(method = "nlminb", 
  #                                             starttests = FALSE, 
  #                                             kkt = FALSE)))
  # somehow the optimx optimizer does not work for the model, the default optimizer is used then.
  
  lmm_scf_rt_zcp <- 
    lmer(log(RT) ~ Alignment + 
           (Ali_C || Subject) +
           (Ali_C || StimGroup),
         filter(df_scf, Correct))
  
  saveRDS(lmm_scf_rt_zcp, thisfile)
}

summary(lmm_scf_rt_zcp)
```

```{r}
summary(rePCA(lmm_scf_rt_zcp))
```
No random effects need to be removed. Therefore, we apply the extended model (i.e., the maximal model in this case) directly.

#### Extended model
```{r}
thisfile <- here("jubail", "lmm_scf_rt_etd.rds")

if (file.exists(thisfile)) {
  
  lmm_scf_rt_etd <- readRDS(thisfile)
  
} else {
  lmm_scf_rt_etd <-
    lmer(log(RT) ~ Alignment +
           (Ali_C | Subject) +
           (Ali_C | StimGroup),
         filter(df_scf, Correct),
         control = lmerControl(optimizer = "optimx",
                               optCtrl = list(method = "nlminb",
                                              starttests = FALSE,
                                              kkt = FALSE)))
  saveRDS(lmm_scf_rt_etd, thisfile)
}

summary(lmm_scf_rt_etd)
```

#### Optimal model
```{r}
anova(lmm_scf_rt_zcp, lmm_scf_rt_etd, refit=FALSE)
```
`lmm_scf_rt_zcp` (with smaller BIC) will be used as the optimal model.

```{r}
lmm_scf_rt_opt <- lmm_scf_rt_zcp
```

#### Effects of interest

```{r}
thisfile <- here("jubail", "emm_scf_rt.rds")

if (file.exists(thisfile)) {
  
  emm_scf_rt <- readRDS(thisfile)
  
} else {
  emm_scf_rt <- emmeans(lmm_scf_rt_opt, ~ Alignment, type="response")
  saveRDS(emm_scf_rt, thisfile)
}

summary(emm_scf_rt)
```

```{r}
contrast(emmeans(lmm_scf_rt_opt, ~ Alignment), "pairwise")
```

```{r}
contrast(emmeans(lmm_scf_rt_opt, ~ Alignment), "pairwise", type = "response")
```


```{r}
emmip(lmm_scf_rt_opt, ~ Alignment, CIs = TRUE, type = "response") 
```


## Complete composite face task

### Sensitivity d'

#### Maximal model
```{r}
# thisfile <- here("jubail", "lmm_ccf_d_max.rds")
# 
# if (file.exists(thisfile)) {
#   
#   lmm_ccf_d_max <- readRDS(thisfile)
#   
# } else {
#   lmm_ccf_d_max <- 
#     glmer(isSame ~ Congruency * Alignment * SD + Cue +
#             (Congruency * Alignment * SD | Subject) +
#             (Congruency * Alignment * SD | StimGroup),
#           df_ccf,
#           family = binomial(link = "probit"),
#           control = glmerControl(optimizer = "optimx", 
#                                  optCtrl = list(method = "nlminb", 
#                                                 starttests = FALSE, 
#                                                 kkt = FALSE)))
#   saveRDS(lmm_ccf_d_max, thisfile)
# }
# 
# summary(lmm_ccf_d_max)
```

#### Zero-correlation-parameter model
```{r}
thisfile <- here("jubail", "lmm_ccf_d_zcp.rds")

if (file.exists(thisfile)) {
  
  lmm_ccf_d_zcp <- readRDS(thisfile)
  
} else {
  # lmm_ccf_d_zcp <- 
  #   glmer(isSame ~ Congruency * Alignment * SD + Cue +
  #           (Con_C + Ali_C + SD_C + 
  #              Con_Ali + Con_SD + Ali_SD + 
  #              Con_Ali_SD || Subject) +
  #           (Con_C + Ali_C + SD_C + 
  #              Con_Ali + Con_SD + Ali_SD + 
  #              Con_Ali_SD || StimGroup),
  #         df_ccf,
  #         family = binomial(link = "probit"),
  #         control = glmerControl(optimizer = "optimx", 
  #                                optCtrl = list(method = "nlminb", 
  #                                               starttests = FALSE, 
  #                                               kkt = FALSE)))
  
  lmm_ccf_d_zcp <- 
    glmer(isSame ~ Congruency * Alignment * SD + Cue +
            (Con_C + Ali_C + SD_C + 
               Con_Ali + Con_SD + Ali_SD + 
               Con_Ali_SD || Subject) +
            (Con_C + Ali_C + SD_C + 
               Con_Ali + Con_SD + Ali_SD + 
               Con_Ali_SD || StimGroup),
          df_ccf,
          family = binomial(link = "probit"))
  saveRDS(lmm_ccf_d_zcp, thisfile)
}

summary(lmm_ccf_d_zcp)
```

```{r}
summary(rePCA(lmm_ccf_d_zcp))
```

By-subject `Con_Ali`, `Con_C`, `Ali_SD`, and by-item `Con_Ali_SD` were removed.

#### Reduced model
```{r}
thisfile <- here("jubail", "lmm_ccf_d_rdc.rds")

if (file.exists(thisfile)) {
  
  lmm_ccf_d_rdc <- readRDS(thisfile)
  
} else {
  lmm_ccf_d_rdc <- 
    glmer(isSame ~ Congruency * Alignment * SD + Cue +
            (Ali_C + SD_C + # Con_C + 
               Con_SD +  # Con_Ali + Ali_SD +
               Con_Ali_SD || Subject) +
            (Con_C + Ali_C + SD_C + 
               Con_Ali + Con_SD + Ali_SD # + 
             || StimGroup), # Con_Ali_SD
          df_ccf,
          family = binomial(link = "probit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  saveRDS(lmm_ccf_d_rdc, thisfile)
}

summary(lmm_ccf_d_rdc)
```

```{r}
summary(rePCA(lmm_ccf_d_rdc))
```

#### Extended model
```{r}
thisfile <- here("jubail", "lmm_ccf_d_etd.rds")

if (file.exists(thisfile)) {
  
  lmm_ccf_d_etd <- readRDS(thisfile)
  
} else {
  lmm_ccf_d_etd <-
    glmer(isSame ~ Congruency * Alignment * SD + Cue +
            (Ali_C + SD_C + # Con_C +
               Con_SD +  # Con_Ali + Ali_SD +
               Con_Ali_SD | Subject) +
            (Con_C + Ali_C + SD_C +
               Con_Ali + Con_SD + Ali_SD # +
             | StimGroup), # Con_Ali_SD
          df_ccf,
          family = binomial(link = "probit"),
          control = glmerControl(optimizer = "optimx",
                                 optCtrl = list(method = "nlminb",
                                                starttests = FALSE,
                                                kkt = FALSE)))
  saveRDS(lmm_ccf_d_etd, thisfile)
}

summary(lmm_ccf_d_etd)
```

```{r}
summary(rePCA(lmm_ccf_d_etd))
```

By-subject `Ali_C`, by-item `Ali_C`, `Con_C`, `Ali_SD`, and `Con_Ali` were removed.

```{r}
thisfile <- here("jubail", "lmm_ccf_d_etd2.rds")

if (file.exists(thisfile)) {
  
  lmm_ccf_d_etd2 <- readRDS(thisfile)
  
} else {
  lmm_ccf_d_etd2 <-
    glmer(isSame ~ Congruency * Alignment * SD + Cue +
            (SD_C + # Con_C + Ali_C + 
               Con_SD +  # Con_Ali + Ali_SD +
               Con_Ali_SD | Subject) +
            (SD_C + # Con_C + Ali_C + 
               Con_SD  # + + Ali_SD Con_Ali + 
             | StimGroup), # Con_Ali_SD
          df_ccf,
          family = binomial(link = "probit"),
          control = glmerControl(optimizer = "optimx",
                                 optCtrl = list(method = "nlminb",
                                                starttests = FALSE,
                                                kkt = FALSE)))
  saveRDS(lmm_ccf_d_etd2, thisfile)
}

summary(lmm_ccf_d_etd2)
```

```{r}
summary(rePCA(lmm_ccf_d_etd2))
```

By-subject `(Intercept)` and by-item `Con_SD` were removed.

```{r}
thisfile <- here("jubail", "lmm_ccf_d_etd3.rds")

if (file.exists(thisfile)) {
  
  lmm_ccf_d_etd3 <- readRDS(thisfile)
  
} else {
  lmm_ccf_d_etd3 <-
    glmer(isSame ~ Congruency * Alignment * SD + Cue +
            (0 + SD_C + # Con_C + Ali_C + 
               Con_SD +  # Con_Ali + Ali_SD +
               Con_Ali_SD | Subject) +
            (SD_C # +  Con_C + Ali_C + 
             # + Con_SD + Ali_SD Con_Ali + 
             | StimGroup), # Con_Ali_SD
          df_ccf,
          family = binomial(link = "probit"),
          control = glmerControl(optimizer = "optimx",
                                 optCtrl = list(method = "nlminb",
                                                starttests = FALSE,
                                                kkt = FALSE)))
  saveRDS(lmm_ccf_d_etd3, thisfile)
}

summary(lmm_ccf_d_etd3)
```

```{r}
summary(rePCA(lmm_ccf_d_etd3))
```

By-subject `Con_Ali_SD` was removed.

```{r}
thisfile <- here("jubail", "lmm_ccf_d_etd4.rds")

if (file.exists(thisfile)) {
  
  lmm_ccf_d_etd4 <- readRDS(thisfile)
  
} else {
  lmm_ccf_d_etd4 <-
    glmer(isSame ~ Congruency * Alignment * SD + Cue +
            (0 + SD_C + # Con_C + Ali_C + 
               Con_SD  # Con_Ali + Ali_SD + + 
             | Subject) + # Con_Ali_SD
            (SD_C # +  Con_C + Ali_C + 
             # + Con_SD + Ali_SD Con_Ali + 
             | StimGroup), # Con_Ali_SD
          df_ccf,
          family = binomial(link = "probit"),
          control = glmerControl(optimizer = "optimx",
                                 optCtrl = list(method = "nlminb",
                                                starttests = FALSE,
                                                kkt = FALSE)))
  saveRDS(lmm_ccf_d_etd4, thisfile)
}

summary(lmm_ccf_d_etd4)
```

```{r}
summary(rePCA(lmm_ccf_d_etd4))
```

#### Optimal model
```{r}
anova(lmm_ccf_d_rdc, lmm_ccf_d_etd4, refit=FALSE)
```

`lmm_ccf_d_rdc` is used as the optimal model.
```{r}
lmm_ccf_d_opt <- lmm_ccf_d_rdc
```

#### Effects of interest
```{r}
(emm_ccf_probit <- emmeans(lmm_ccf_d_opt, ~ Congruency + Alignment + SD, type = "response"))
```


```{r}
emm_ccf_d <- contrast(emm_ccf_probit, "pairwise", simple="SD")
emm_ccf_d[1:4]
```

```{r}
cong_emm <- contrast(emm_ccf_probit, interaction="pairwise", by="Alignment")
cong_emm[2]
```

```{r}
contrast(emm_ccf_probit, interaction="pairwise")
```


```{r}
emmip(emm_ccf_d, Congruency ~ Alignment, CIs = TRUE)
```


### Correct response times

#### Maximal model
```{r}
# thisfile <- here("jubail", "lmm_ccf_rt_max.rds")
# 
# if (file.exists(thisfile)) {
#   
#   lmm_ccf_rt_max <- readRDS(thisfile)
#   
# } else {
#   lmm_ccf_rt_max <- 
#     lmer(log(RT) ~ Congruency * Alignment + SD + Cue +
#            (Congruency * Alignment | Subject) +
#            (Congruency * Alignment | StimGroup),
#          filter(df_ccf, Correct),
#          control = lmerControl(optimizer = "optimx",
#                                optCtrl = list(method = "nlminb",
#                                               starttests = FALSE,
#                                               kkt = FALSE)))
#   saveRDS(lmm_ccf_rt_max, thisfile)
# }
# 
# summary(lmm_ccf_rt_max)
```

#### Zero-correlation-parameter model
```{r}
thisfile <- here("jubail", "lmm_ccf_rt_zcp.rds")

if (file.exists(thisfile)) {
  
  lmm_ccf_rt_zcp <- readRDS(thisfile)
  
} else {
  # lmm_ccf_rt_zcp <-
  #   lmer(log(RT) ~ Congruency * Alignment + SD + Cue +
  #          (Con_C + Ali_C + Con_Ali || Subject) +
  #          (Con_C + Ali_C + Con_Ali || StimGroup),
  #        filter(df_ccf, Correct),
  #        control = lmerControl(optimizer = "optimx",
  #                              optCtrl = list(method = "nlminb",
  #                                             starttests = FALSE,
  #                                             kkt = FALSE)))
  
  # try the default optimizer
  lmm_ccf_rt_zcp <- 
    lmer(log(RT) ~ Congruency * Alignment + SD + Cue + 
           (Con_C + Ali_C + Con_Ali || Subject) +
           (Con_C + Ali_C + Con_Ali || StimGroup),
         filter(df_ccf, Correct),
         control = lmerControl(optCtrl = list(maxiter = 1e7)))
  saveRDS(lmm_ccf_rt_zcp, thisfile)
}

summary(lmm_ccf_rt_zcp)
```

```{r}
summary(rePCA(lmm_ccf_rt_zcp))
```

By-item `Con_Ali` was removed.

#### Reduced model
```{r}
thisfile <- here("jubail", "lmm_ccf_rt_rdc.rds")

if (file.exists(thisfile)) {
  
  lmm_ccf_rt_rdc <- readRDS(thisfile)
  
} else {
  # lmm_ccf_rt_rdc <- 
  #   lmer(log(RT) ~ Congruency * Alignment + SD + Cue +
  #          (Con_C + Ali_C + Con_Ali || Subject) +  
  #          (Con_C + Ali_C || StimGroup), # + Con_Ali
  #        filter(df_ccf, Correct),
  #        control = lmerControl(optimizer = "optimx",
  #                              optCtrl = list(method = "nlminb",
  #                                             starttests = FALSE,
  #                                             kkt = FALSE)))
  
  # try the default optimizer
  lmm_ccf_rt_rdc <- 
    lmer(log(RT) ~ Congruency * Alignment + SD + Cue + 
           (Con_C + Ali_C + Con_Ali || Subject) +
           (Con_C + Ali_C || StimGroup), # + Con_Ali
         filter(df_ccf, Correct),
         control = lmerControl(optCtrl = list(maxiter = 1e7)))
  saveRDS(lmm_ccf_rt_rdc, thisfile)
}

summary(lmm_ccf_rt_rdc)
```

```{r}
summary(rePCA(lmm_ccf_rt_rdc))
```

#### Extended model
```{r}
thisfile <- here("jubail", "lmm_ccf_rt_etd.rds")

if (file.exists(thisfile)) {
  
  lmm_ccf_rt_etd <- readRDS(thisfile)
  
} else {
  
  lmm_ccf_rt_etd <- 
    lmer(log(RT) ~ Congruency * Alignment + SD + Cue + 
           (Con_C + Ali_C + Con_Ali | Subject) +
           (Con_C + Ali_C | StimGroup), # + Con_Ali
         filter(df_ccf, Correct),
         control = lmerControl(optCtrl = list(maxiter = 1e7)))
  
  saveRDS(lmm_ccf_rt_etd, thisfile)
}

summary(lmm_ccf_rt_etd)
```

```{r}
summary(rePCA(lmm_ccf_rt_etd))
```
By-subject `Con_C` was removed.

```{r}
thisfile <- here("jubail", "lmm_ccf_rt_etd2.rds")

if (file.exists(thisfile)) {
  
  lmm_ccf_rt_etd2 <- readRDS(thisfile)
  
} else {
  
  lmm_ccf_rt_etd2 <- 
    lmer(log(RT) ~ Congruency * Alignment + SD + Cue + 
           (Ali_C + Con_Ali | Subject) + # Con_C + 
           (Con_C + Ali_C | StimGroup), # + Con_Ali
         filter(df_ccf, Correct),
         control = lmerControl(optCtrl = list(maxiter = 1e7)))
  
  saveRDS(lmm_ccf_rt_etd2, thisfile)
}

summary(lmm_ccf_rt_etd2)
```

```{r}
summary(rePCA(lmm_ccf_rt_etd2))
```
By-item `Con_C` was removed.

```{r}
thisfile <- here("jubail", "lmm_ccf_rt_etd3.rds")

if (file.exists(thisfile)) {
  
  lmm_ccf_rt_etd3 <- readRDS(thisfile)
  
} else {
  
  lmm_ccf_rt_etd3 <- 
    lmer(log(RT) ~ Congruency * Alignment + SD + Cue + 
           (Ali_C + Con_Ali | Subject) + # Con_C + 
           (Ali_C | StimGroup), # + Con_Ali + Con_C + 
         filter(df_ccf, Correct),
         control = lmerControl(optCtrl = list(maxiter = 1e7)))
  
  saveRDS(lmm_ccf_rt_etd3, thisfile)
}

summary(lmm_ccf_rt_etd3)
```

```{r}
summary(rePCA(lmm_ccf_rt_etd3))
```

#### Optimal model
```{r}
anova(lmm_ccf_rt_rdc, lmm_ccf_rt_etd3, refit=FALSE)
```

`lmm_ccf_rt_rdc` is used as the optimal model.
```{r}
lmm_ccf_rt_opt <- lmm_ccf_rt_rdc
```

#### Effects of interest
```{r}
(emm_ccf_rt <- emmeans(lmm_ccf_rt_opt, ~ Congruency + Alignment, type = "response"))
```

```{r}
# thisfile <- here("jubail", "emm_ccf_rt.rds")
# 
# if (file.exists(thisfile)) {
#   
#   emm_ccf_rt <- readRDS(thisfile)
#   
# } else {
#   emm_ccf_rt <- emmeans(lmm_ccf_rt_opt, ~ Congruency + Alignment, type = "response",
#                         lmer.df = "kenward-roger", pbkrtest.limit = 110000)
#   saveRDS(emm_ccf_rt, thisfile)
# }
# 
# summary(emm_ccf_rt)
```

```{r}
contrast(emm_ccf_rt, interaction="pairwise")
```

```{r}
contrast(emm_ccf_rt, interaction="pairwise", type = "response")
```

```{r}
emmip(emm_ccf_rt, Congruency ~ Alignment, CIs = TRUE, type = "response") 
```


## Facilitation and interference in the complete composite face task

### Sensitivity d'

#### Maximal model
```{r}
# thisfile <- here("jubail", "lmm_fi_d_max.rds")
# 
# if (file.exists(thisfile)) {
#   
#   lmm_fi_d_max <- readRDS(thisfile)
#   
# } else {
#   lmm_fi_d_max <- 
#     glmer(isSame ~ Congruency * SD + Cue +
#             (Congruency * SD | Subject) +
#             (Congruency * SD | StimGroup),
#           df_fi,
#           family = binomial(link = "probit"),
#           control = glmerControl(optimizer = "optimx", 
#                                  optCtrl = list(method = "nlminb", 
#                                                 starttests = FALSE, 
#                                                 kkt = FALSE)))
#   saveRDS(lmm_fi_d_max, thisfile)
# }
# 
# summary(lmm_fi_d_max)
```

#### Zero-correlation-parameter model
```{r}
thisfile <- here("jubail", "lmm_fi_d_zcp.rds")

if (file.exists(thisfile)) {
  
  lmm_fi_d_zcp <- readRDS(thisfile)
  
} else {
  lmm_fi_d_zcp <- 
    glmer(isSame ~ Congruency * SD + Cue +
            (ConInc + IncIso + SD_C + 
               ConInc_SD + IncIso_SD || Subject) +
            (ConInc + IncIso + SD_C + 
               ConInc_SD + IncIso_SD || StimGroup),
          df_fi,
          family = binomial(link = "probit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  saveRDS(lmm_fi_d_zcp, thisfile)
}

summary(lmm_fi_d_zcp)
```

```{r}
summary(rePCA(lmm_fi_d_zcp))
```

#### Extended model
```{r}
thisfile <- here("jubail", "lmm_fi_d_etd.rds")

if (file.exists(thisfile)) {
  
  lmm_fi_d_etd <- readRDS(thisfile)
  
} else {
  lmm_fi_d_etd <- 
    glmer(isSame ~ Congruency * SD + Cue +
            (ConInc + IncIso + SD_C + 
               ConInc_SD + IncIso_SD | Subject) +
            (ConInc + IncIso + SD_C + 
               ConInc_SD + IncIso_SD | StimGroup),
          df_fi,
          family = binomial(link = "probit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  saveRDS(lmm_fi_d_etd, thisfile)
}

summary(lmm_fi_d_etd)
```

```{r}
summary(rePCA(lmm_fi_d_etd))
```

By-subject `ConInc`, `IncIso`, by-item `(Intercept)`, `ConInc`, and `IncIso` were removed.

```{r}
thisfile <- here("jubail", "lmm_fi_d_etd2.rds")

if (file.exists(thisfile)) {
  
  lmm_fi_d_etd2 <- readRDS(thisfile)
  
} else {
  lmm_fi_d_etd2 <-
    glmer(isSame ~ Congruency * SD + Cue +
            (SD_C + # ConInc + IncIso +
               ConInc_SD + IncIso_SD | Subject) +
            (0 + SD_C + # ConInc + IncIso +
               ConInc_SD + IncIso_SD | StimGroup),
          df_fi,
          family = binomial(link = "probit"),
          control = glmerControl(optimizer = "optimx",
                                 optCtrl = list(method = "nlminb",
                                                starttests = FALSE,
                                                kkt = FALSE)))
  saveRDS(lmm_fi_d_etd2, thisfile)
}

summary(lmm_fi_d_etd2)
```

```{r}
summary(rePCA(lmm_fi_d_etd2))
```

By-subject `(Intercept)` and by-item `IncIso_SD` were removed.

```{r}
thisfile <- here("jubail", "lmm_fi_d_etd3.rds")

if (file.exists(thisfile)) {
  
  lmm_fi_d_etd3 <- readRDS(thisfile)
  
} else {
  lmm_fi_d_etd3 <-
    glmer(isSame ~ Congruency * SD + Cue +
            (0 + SD_C + # ConInc + IncIso +
               ConInc_SD + IncIso_SD | Subject) +
            (0 + SD_C + # ConInc + IncIso +
               ConInc_SD | StimGroup), # + IncIso_SD
          df_fi,
          family = binomial(link = "probit"),
          control = glmerControl(optimizer = "optimx",
                                 optCtrl = list(method = "nlminb",
                                                starttests = FALSE,
                                                kkt = FALSE)))
  saveRDS(lmm_fi_d_etd3, thisfile)
}

summary(lmm_fi_d_etd3)
```

```{r}
summary(rePCA(lmm_fi_d_etd3))
```
By-subject `IncIso_SD` was removed.

```{r}
thisfile <- here("jubail", "lmm_fi_d_etd4.rds")

if (file.exists(thisfile)) {
  
  lmm_fi_d_etd4 <- readRDS(thisfile)
  
} else {
  lmm_fi_d_etd4 <-
    glmer(isSame ~ Congruency * SD + Cue +
            (0 + SD_C + # ConInc + IncIso +
               ConInc_SD | Subject) + # + IncIso_SD
            (0 + SD_C + # ConInc + IncIso +
               ConInc_SD | StimGroup), # + IncIso_SD
          df_fi,
          family = binomial(link = "probit"),
          control = glmerControl(optimizer = "optimx",
                                 optCtrl = list(method = "nlminb",
                                                starttests = FALSE,
                                                kkt = FALSE)))
  saveRDS(lmm_fi_d_etd4, thisfile)
}

summary(lmm_fi_d_etd4)
```

```{r}
summary(rePCA(lmm_fi_d_etd4))
```

#### Optimal model
```{r}
anova(lmm_fi_d_zcp, lmm_fi_d_etd4, refit=FALSE)
```

`lmm_fi_d_zcp` is used as the optimal model.
```{r}
lmm_fi_d_opt <- lmm_fi_d_zcp
```

#### Effects of interest
```{r}
(emm_fi_probit <- emmeans(lmm_fi_d_opt, ~ Congruency + SD, type = "response"))
```


```{r}
emm_fi_d <- contrast(emm_fi_probit, "pairwise", simple="SD")
emm_fi_d[1:3]
```

```{r}
cong_emm <- contrast(emm_fi_probit, interaction="pairwise")
cong_emm[2:3]
```


```{r}
emmip(emm_fi_d, ~ Congruency, CIs = TRUE)
```


### Correct response times

#### Maximal model
```{r}
# thisfile <- here("jubail", "lmm_fi_rt_max.rds")
# 
# if (file.exists(thisfile)) {
#   
#   lmm_fi_rt_max <- readRDS(thisfile)
#   
# } else {
#   lmm_fi_rt_max <- 
#     lmer(log(RT) ~ Congruency + SD + Cue +
#            (Congruency | Subject) +
#            (Congruency | StimGroup),
#          filter(df_fi, Correct),
#          control = lmerControl(optimizer = "optimx", 
#                                optCtrl = list(method = "nlminb", 
#                                               starttests = FALSE, 
#                                               kkt = FALSE)))
#   saveRDS(lmm_fi_rt_max, thisfile)
# }
# 
# summary(lmm_fi_rt_max)
```

#### Zero-correlation-parameter model
```{r}
thisfile <- here("jubail", "lmm_fi_rt_zcp.rds")

if (file.exists(thisfile)) {
  
  lmm_fi_rt_zcp <- readRDS(thisfile)
  
} else {
  lmm_fi_rt_zcp <- 
    lmer(log(RT) ~ Congruency + SD + Cue +
           (ConInc + IncIso || Subject) +
           (ConInc + IncIso || StimGroup),
         filter(df_fi, Correct),
         control = lmerControl(optCtrl = list(maxiter = 1e7)))
  saveRDS(lmm_fi_rt_zcp, thisfile)
}

summary(lmm_fi_rt_zcp)
```

```{r}
summary(rePCA(lmm_fi_rt_zcp))
```
No random effects need to be removed. Therefore, we apply the extended model (i.e., the maximal model in this case) directly.

#### Extended model
```{r}
thisfile <- here("jubail", "lmm_fi_rt_etd.rds")

if (file.exists(thisfile)) {
  
  lmm_fi_rt_etd <- readRDS(thisfile)
  
} else {
  lmm_fi_rt_etd <- 
    lmer(log(RT) ~ Congruency + SD + Cue +
           (ConInc + IncIso | Subject) +
           (ConInc + IncIso | StimGroup),
         filter(df_fi, Correct),
         control = lmerControl(optCtrl = list(maxiter = 1e7)))
  saveRDS(lmm_fi_rt_etd, thisfile)
}

summary(lmm_fi_rt_etd)
```

```{r}
summary(rePCA(lmm_fi_rt_etd))
```
By-item `(Intercept)` was removed.

```{r}
thisfile <- here("jubail", "lmm_fi_rt_etd2.rds")

if (file.exists(thisfile)) {
  
  lmm_fi_rt_etd2 <- readRDS(thisfile)
  
} else {
  lmm_fi_rt_etd2 <- 
    lmer(log(RT) ~ Congruency + SD + Cue +
           (ConInc + IncIso | Subject) +
           (0 + ConInc + IncIso | StimGroup), 
         filter(df_fi, Correct),
         control = lmerControl(optCtrl = list(maxiter = 1e7)))
  saveRDS(lmm_fi_rt_etd2, thisfile)
}

summary(lmm_fi_rt_etd2)
```

By-subject `ConInc` was removed.
```{r}
summary(rePCA(lmm_fi_rt_etd2))
```

```{r}
thisfile <- here("jubail", "lmm_fi_rt_etd3.rds")

if (file.exists(thisfile)) {
  
  lmm_fi_rt_etd3 <- readRDS(thisfile)
  
} else {
  lmm_fi_rt_etd3 <- 
    lmer(log(RT) ~ Congruency + SD + Cue +
           (ConInc + IncIso | Subject) +
           (0 + IncIso | StimGroup), # ConInc + 
         filter(df_fi, Correct),
         control = lmerControl(optCtrl = list(maxiter = 1e7)))
  saveRDS(lmm_fi_rt_etd3, thisfile)
}

summary(lmm_fi_rt_etd3)
```

#### Optimal model
```{r}
anova(lmm_fi_rt_zcp, lmm_fi_rt_etd3, refit=FALSE)
```

`lmm_fi_rt_etd3` is used as the optimal model.
```{r}
lmm_fi_rt_opt <- lmm_fi_rt_etd3
```

#### Effects of interest
```{r}
(emm_fi_rt <- emmeans(lmm_fi_rt_opt, ~ Congruency, type = "response"))
```

```{r}
# thisfile <- here("jubail", "emm_fi_rt.rds")
# 
# if (file.exists(thisfile)) {
#   
#   emm_fi_rt <- readRDS(thisfile)
#   
# } else {
#   emm_fi_rt <- emmeans(lmm_fi_rt_opt, ~ Congruency, type = "response",
#                         lmer.df = "kenward-roger", pbkrtest.limit = 83000)
#   saveRDS(emm_fi_rt, thisfile)
# }
# 
# summary(emm_fi_rt)
```

```{r}
contrast(emm_fi_rt, "pairwise")[c(2,3)]
```

```{r}
contrast(emm_fi_rt, "pairwise", type = "response")[c(2,3)]
```


```{r}
emmip(emm_fi_rt,  ~ Congruency, CIs = TRUE, type = "response") 
```

