---
title: "Two faces of holistic face processing -- analyses and results"
author: "[Haiyang Jin](https://haiyangjin.github.io/)"
date: "`r format(Sys.time(), '%d-%m-%Y')`"
output: 
  html_document:
    code_folding: hide
    number_sections: true
    toc: true
    toc_depth: 4
    toc_float: true
---

```{=html}
<style>
pre {
overflow-x: auto;
}
pre code {
word-wrap: normal;
white-space: pre;
}
</style>
```

```{r global_options, echo = FALSE, include = FALSE}
options(width = 1500)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, 
                      include = TRUE, cache = FALSE, tidy = FALSE, 
                      size = "big", fig.width=8, fig.asp=0.7)
xaringanExtra::use_clipboard()
```

# Preparations
```{r setup}
## load libraries
library(tidyverse)
library(lme4)
library(lmerTest)
library(optimx)
library(emmeans)
library(psych)
library(ggpubr)
```

```{r}
two_colors <- c("#D55E00", "#56B4E9")

# APA theme for figures
theme_set(papaja::theme_apa(base_size = 12, base_family = "Helvetica", box = FALSE))
theme_update(strip.placement = "outside")
```

## Load data 
```{r read the data file}
# list filenames
prolific_list <- list.files(file.path("data", "pilot", "prolific"), 
                            pattern = "*.csv", full.names = TRUE)
testable1_list <- list.files(file.path("data", "pilot", "testable1"), 
                             pattern = "*.csv", full.names = TRUE)

# load data
df_raw_p <- map_dfr(prolific_list, read_csv, show_col_types = FALSE, .id="id") 
df_raw_t1 <- map_dfr(testable1_list, read_csv, show_col_types = FALSE, .id="id") 

# combine data from the two experiments
df_raw_p_tmp <- df_raw_p %>% 
  filter(trial_frame=="test_face") %>% 
  select(Exp_name, Subject, CBcode, isPavlovia, Task_name:SameDifferent, 
         Correct_ans_posi, Correct_response, response, Correct, RT, StimGroup, StudyFace, TestFace) %>% 
  mutate(platform = "Prolific")

df_raw_t1_tmp <- df_raw_t1 %>% 
  filter(trial_frame=="test_face") %>% 
  select(Exp_name, Subject, CBcode, isPavlovia, Task_name:SameDifferent, 
         Correct_ans_posi, Correct_response, response, Correct, RT, StimGroup, StudyFace, TestFace) %>% 
  mutate(platform = "Testable1")

df_raw <- bind_rows(df_raw_p_tmp, df_raw_t1_tmp) %>% 
  filter(Section=="main") %>% # exclude practice trials
  mutate(Exp_name = as_factor(Exp_name),
         Subject = paste0("subj",as.numeric(as_factor(Subject))),
         Subject = as_factor(Subject),
         Task = as_factor(Task_name),
         PW = as_factor(PW), 
         Feature = as_factor(Feature),
         Cue = as_factor(Cue),
         Congruency = as_factor(Congruency),
         Alignment = as_factor(Alignment),
         SameDifferent = as_factor(SameDifferent),
         Correct_ans_posi = as_factor(Correct_ans_posi),
         StimGroup = if_else(Task_name=="PW", str_remove(basename(StudyFace),".png"), StimGroup),
         platform = as_factor(platform)) %>% 
  select(-c(Section))

head(df_raw)
```

## Tidy data

Remove outlier participants and outlier trials. 
```{r}
df_tidy <- df_raw 
```


### Part-whole task

```{r}
df_pw <- df_tidy %>% 
  filter(Task_name == "PW",
         Feature != "nose") %>% # do not include Nose trials in GLMM
  select(Subject, PW, Feature, Correct, RT, StimGroup) %>% 
  mutate(PW_C = if_else(PW=="part", -.5, if_else(PW=="whole", .5, NaN)),
         Feature_C = if_else(Feature=="mouth", -.5, 
                             if_else(Feature=="eyes", .5, NaN)),
         PW_Feature = PW_C * Feature_C) 

# saveRDS(df_pw, file=file.path("jubail", "df_pw.rds"))

head(df_pw)
```

### Standard composite face task

```{r}
df_scf <- df_tidy %>% 
  filter(Task_name == "SCF",
         SameDifferent == "same") %>% # only use trials when the top is the same
  select(Subject, Alignment, Correct, RT, StimGroup) 

head(df_scf)
```

### Complete composite face task

```{r}
# including isolated condition
df_ccf_iso <- df_tidy %>% 
  filter(Task_name == "CCF") %>% # only use trials when the top is the same
  mutate(isSame = if_else( # whether participants responded "same" (signal)
    ((SameDifferent=="same")&Correct) | ((SameDifferent=="different")&!Correct), 1,
    if_else(((SameDifferent=="same")&!Correct) | ((SameDifferent=="different")&Correct), 0, NaN))) %>% 
  select(Subject, Cue, Congruency, Alignment, SD=SameDifferent, Correct, isSame, RT, StimGroup) 

df_ccf <- df_ccf_iso %>% 
  filter(Alignment != "isolated")

head(df_ccf)
```


# Holistic processing effects

Linear mixed-effects models are used to examine the holistic processing effects in the part-whole, standard composite face task, and complete composite face task.

## Steps to obtain the optimal model

1. If the maximal model did not converge, correlations between random effects were removed, making the zero-correlation-parameter (ZCP) model. 
2. Principal component analysis implemented with `rePCA()` function was then used to identify random effects that explained less than 0.1% of the total variances; they were removed from the ZCP model to make the reduced model. 
3. The extended model was built by adding back the correlations between random effects in the reduced model. 
4. If the extended model did not converge, the random effects that explained less than 1% of total variances were identified by `rePCA()` and removed to make the updated extended model; this step was iterated until an extended model converged. 
5. The converged extended model was then compared to the reduced model via `anova()` function and the model that explained the data better (with smaller Bayesian Information Criterion) was used as the optimal model. 
6. All follow-up analyses were performed on the optimal model. 

## Part-whole task

### Accuracy 

#### Maximal model

```{r}
thisfile <- file.path("jubail", "lmm_pw_acc_max.rds")

if (file.exists(thisfile)) {
  
  lmm_pw_acc_max <- readRDS(thisfile)
  
} else {
  lmm_pw_acc_max <- 
    glmer(Correct ~ PW * Feature + (PW * Feature | Subject),
          df_pw,
          family = binomial(link = "logit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  saveRDS(lmm_pw_acc_max, thisfile)
}

summary(lmm_pw_acc_max)
```

#### Zero-correlation-parameter model

```{r}
thisfile <- file.path("jubail", "lmm_pw_acc_zcp.rds")

if (file.exists(thisfile)) {
  
  lmm_pw_acc_zcp <- readRDS(thisfile)
  
} else {
  lmm_pw_acc_zcp <- 
    glmer(Correct ~ PW * Feature + 
            (PW_C + Feature_C + PW_Feature || Subject),
          df_pw,
          family = binomial(link = "logit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  saveRDS(lmm_pw_acc_zcp, thisfile)
}

summary(lmm_pw_acc_zcp)
```

```{r}
summary(rePCA(lmm_pw_acc_zcp))
```

#### Reduced model

```{r}
thisfile <- file.path("jubail", "lmm_pw_acc_rdc.rds")

if (file.exists(thisfile)) {
  
  lmm_pw_acc_rdc <- readRDS(thisfile)
  
} else {
  lmm_pw_acc_rdc <- 
    glmer(Correct ~ PW * Feature + 
            (PW_C + Feature_C || Subject),
          df_pw,
          family = binomial(link = "logit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  saveRDS(lmm_pw_acc_rdc, thisfile)
}

summary(lmm_pw_acc_rdc)
```

#### Extended model

```{r}
thisfile <- file.path("jubail", "lmm_pw_acc_etd.rds")

if (file.exists(thisfile)) {
  
  lmm_pw_acc_etd <- readRDS(thisfile)
  
} else {
  lmm_pw_acc_etd <- 
    glmer(Correct ~ PW * Feature + 
            (PW_C + Feature_C | Subject),
          df_pw,
          family = binomial(link = "logit"),
          control = glmerControl(optimizer = "optimx", 
                                 optCtrl = list(method = "nlminb", 
                                                starttests = FALSE, 
                                                kkt = FALSE)))
  saveRDS(lmm_pw_acc_etd, thisfile)
}

summary(lmm_pw_acc_etd)
```

#### Optimal model

```{r}
anova(lmm_pw_acc_rdc, lmm_pw_acc_etd)
```

```{r}
lmm_pw_acc_opt <- lmm_pw_acc_etd
```

#### Effects of interest
```{r}
emm_pw_acc <- emmeans(lmm_pw_acc_opt, ~ PW + Feature, type = "response")
emm_pw_acc
```

```{r}
contrast(emmeans(lmm_pw_acc_opt, ~ PW), "revpairwise")
```

```{r}
contrast(emmeans(lmm_pw_acc_opt, ~ PW), "revpairwise", type="response")
```

```{r}
contrast(emmeans(lmm_pw_acc_opt, ~ PW | Feature), "pairwise")
```


```{r}
emmip(lmm_pw_acc_opt, ~ PW | Feature, CIs = TRUE, type = "response") 
```


### Correct response times

```{r}
lmm_pw_rt <- lmer(log(RT) ~ PW * Feature + (PW * Feature | Subject),
                  filter(df_pw, Correct),
                  control = lmerControl(optimizer = "optimx", 
                                        optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE)))

summary(lmm_pw_rt)
```


```{r}
emm_pw_rt <- emmeans(lmm_pw_acc_opt, ~ PW + Feature)
emm_pw_rt
```

```{r}
contrast(emmeans(lmm_pw_rt, ~ PW), "pairwise")
```

```{r}
contrast(emmeans(lmm_pw_rt, ~ PW), "pairwise", type = "response")
```

```{r}
contrast(emmeans(lmm_pw_rt, ~ PW | Feature), "pairwise")
```


```{r}
emmip(lmm_pw_rt, ~ PW | Feature, CIs = TRUE, type = "response") 
```


## Standard composite face task

### Accuracy 

```{r}
lmm_scf_acc <- glmer(Correct ~ Alignment + (Alignment | Subject),
                     df_scf,
                     family = binomial(link = "logit"),
                     control = glmerControl(optimizer = "optimx", 
                                            optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE)))

summary(lmm_scf_acc)
```


```{r}
emm_scf_acc <- emmeans(lmm_scf_acc, ~ Alignment, type="response")
emm_scf_acc
```

```{r}
contrast(emmeans(lmm_scf_acc, ~ Alignment), "pairwise")
```


```{r}
emmip(lmm_scf_acc, ~ Alignment, CIs = TRUE, type = "response") 
```



### Correct response times

```{r}
lmm_scf_rt <- lmer(log(RT) ~ Alignment + (Alignment | Subject),
                   filter(df_scf, Correct),
                   control = lmerControl(optimizer = "optimx", 
                                         optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE)))

summary(lmm_scf_rt)
```


```{r}
emm_scf_rt <- emmeans(lmm_scf_rt, ~ Alignment, type = "response")
emm_scf_rt
```

```{r}
contrast(emmeans(lmm_scf_rt, ~ Alignment), "pairwise")
```

```{r}
contrast(emmeans(lmm_scf_rt, ~ Alignment), "pairwise", type = "response")
```


```{r}
emmip(lmm_scf_rt, ~ Alignment, CIs = TRUE, type = "response") 
```


## Complete composite face task

### Sensitivity d'

```{r}
lmm_ccf_d <- glmer(isSame ~ Congruency * Alignment * SD + Cue +
                     (Congruency * Alignment * SD | Subject),
                   df_ccf,
                   family = binomial(link = "probit"),
                   control = glmerControl(optimizer = "optimx", 
                                          optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE)))

summary(lmm_ccf_d)
```

```{r}
(emm_ccf_probit <- emmeans(lmm_ccf_d, ~ Congruency + Alignment + SD, type = "response"))
```


```{r}
emm_ccf_d <- contrast(emm_ccf_probit, "pairwise", simple="SD")
emm_ccf_d[1:4]
```

```{r}
cong_emm <- contrast(emm_ccf_probit, interaction="pairwise", by="Alignment")
cong_emm[2]
```

```{r}
contrast(emm_ccf_probit, interaction="pairwise")
```


```{r}
emmip(emm_ccf_d, Congruency ~ Alignment, CIs = TRUE)
```



### Correct response times


```{r}
lmm_ccf_rt <- lmer(log(RT) ~ Congruency * Alignment + (Congruency * Alignment | Subject),
                   filter(df_ccf, Correct),
                   control = lmerControl(optimizer = "optimx", 
                                         optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE)))

summary(lmm_ccf_rt)
```

```{r}
emm_ccf_rt <- emmeans(lmm_ccf_rt, ~ Congruency + Alignment, type = "response",
                      lmerTest.limit = 6400,
                      pbkrtest.limit = 6400)
emm_ccf_rt
```

```{r}
contrast(emm_ccf_rt, interaction="pairwise")
```

```{r}
contrast(emm_ccf_rt, interaction="pairwise", type = "response")
```


```{r}
emmip(emm_ccf_rt, Congruency ~ Alignment, CIs = TRUE, type = "response") 
```


# Relationships among effects


## Calculate holistic processing effects

### Part-whole task

#### Subtraction

```{r}
pwe_acc <- df_pw %>% 
  group_by(Subject, PW) %>% 
  summarize(acc = mean(Correct),
            .groups = "drop") %>% 
  pivot_wider(Subject, names_from = PW, values_from = acc) %>% 
  mutate(pwe_subt = whole - part)
  
pwe_acc
```


```{r}
pwe_rt <- df_pw %>% 
  filter(Correct) %>% 
  group_by(Subject, PW) %>% 
  summarize(rt = mean(RT),
            .groups = "drop") %>% 
  pivot_wider(Subject, names_from = PW, values_from = rt) %>% 
  mutate(pwe_subt = whole - part)
  
pwe_rt
```


#### Regression

```{r}
lm_pwe_acc <- lm(whole ~ part, pwe_acc)
summary(lm_pwe_acc)
```

```{r}
pwe_acc <- pwe_acc %>% 
  mutate(pwe_regr = residuals(lm_pwe_acc))
pwe_acc
```


```{r}
lm_pwe_rt <- lm(whole ~ part, pwe_rt)
summary(lm_pwe_rt)
```

```{r}
pwe_rt <- pwe_rt %>% 
  mutate(pwe_regr = residuals(lm_pwe_rt))
pwe_rt
```


### Standard composite face task

#### Subtraction

```{r}
scfe_acc <- df_scf %>% 
  group_by(Subject, Alignment) %>% 
  summarize(acc = mean(Correct),
            .groups = "drop") %>% 
  pivot_wider(Subject, names_from = Alignment, values_from = acc) %>% 
  mutate(scfe_subt = aligned - misaligned)
scfe_acc
```


```{r}
scfe_rt <- df_scf %>% 
  filter(Correct) %>% 
  group_by(Subject, Alignment) %>% 
  summarize(rt = mean(RT),
            .groups = "drop") %>% 
  pivot_wider(Subject, names_from = Alignment, values_from = rt) %>% 
  mutate(scfe_subt = aligned - misaligned)
scfe_rt
```

#### Regression

```{r}
lm_scfe_acc <- lm(aligned ~ misaligned, scfe_acc)
summary(lm_scfe_acc)
```

```{r}
scfe_acc <- scfe_acc %>% 
  mutate(scfe_regr = residuals(lm_scfe_acc))
scfe_acc
```


```{r}
lm_scfe_rt <- lm(aligned ~ misaligned, scfe_rt)
summary(lm_scfe_rt)
```


```{r}
scfe_rt <- scfe_rt %>% 
  mutate(scfe_regr = residuals(lm_scfe_rt))
scfe_rt
```


### Complete compositie face task

#### Subtraction

```{r}
ccfe_d <- df_ccf_iso %>% 
  group_by(Subject, Congruency, Alignment, SD) %>% 
  summarize(count = n(),
            same_adjust = (sum(isSame)+0.5)/(count+1), # Snodgrass & Corwin (1988)
            .groups = "drop") %>% 
  mutate(z = qnorm(same_adjust)) %>% 
  select(-same_adjust) %>% 
  pivot_wider(names_from = "SD", values_from = z) %>% 
  mutate(d = same - different) %>% 
  pivot_wider(Subject, names_from = c(Congruency, Alignment), values_from = d) %>% 
  rename(isolated = isolated_isolated) %>% 
  mutate(fac_subt = congruent_aligned - congruent_misaligned,
         int_subt = incongruent_aligned - incongruent_misaligned,
         ccfe_subt = fac_subt - int_subt,
         fac_subt_iso = congruent_aligned - isolated,
         int_subt_iso = incongruent_aligned - isolated)
ccfe_d
```


```{r}
ccfe_rt <- df_ccf_iso %>% 
  filter(Correct) %>% 
  group_by(Subject, Congruency, Alignment) %>% 
  summarize(rt = mean(RT),
            .groups = "drop") %>% 
  pivot_wider(Subject, names_from = c(Congruency, Alignment), values_from = rt) %>% 
  rename(isolated = isolated_isolated) %>% 
  mutate(fac_subt = congruent_aligned - congruent_misaligned,
         int_subt = incongruent_aligned - incongruent_misaligned,
         ccfe_subt = fac_subt - int_subt,
         fac_subt_iso = congruent_aligned - isolated,
         int_subt_iso = incongruent_aligned - isolated)

ccfe_rt
```


#### Regression

Facilitation
```{r}
lm_ccfe_d_fac <- lm(congruent_aligned ~ congruent_misaligned, ccfe_d)
summary(lm_ccfe_d_fac)
```

```{r}
ccfe_d <- ccfe_d %>% 
  mutate(fac_regr = residuals(lm_ccfe_d_fac))
ccfe_d
```


Facilitation (isolated)
```{r}
lm_ccfe_d_fac_iso <- lm(congruent_aligned ~ isolated, ccfe_d)
summary(lm_ccfe_d_fac_iso)
```

```{r}
ccfe_d <- ccfe_d %>% 
  mutate(fac_regr_iso = residuals(lm_ccfe_d_fac_iso))
ccfe_d
```


Interference
```{r}
lm_ccfe_d_int <- lm(incongruent_aligned ~ incongruent_misaligned, ccfe_d)
summary(lm_ccfe_d_int)
```

```{r}
ccfe_d <- ccfe_d %>% 
  mutate(int_regr = residuals(lm_ccfe_d_int))
ccfe_d
```

Interference (isolated)
```{r}
lm_ccfe_d_int_iso <- lm(incongruent_aligned ~ isolated, ccfe_d)
summary(lm_ccfe_d_int_iso)
```

```{r}
ccfe_d <- ccfe_d %>% 
  mutate(int_regr_iso = residuals(lm_ccfe_d_int_iso))
ccfe_d
```

Facilitation 

```{r}
lm_ccfe_rt_fac <- lm(congruent_aligned ~ congruent_misaligned, ccfe_rt)
summary(lm_ccfe_rt_fac)
```

```{r}
ccfe_rt <- ccfe_rt %>% 
  mutate(fac_regr = residuals(lm_ccfe_rt_fac))
ccfe_rt
```


Facilitation (isolated)
```{r}
lm_ccfe_rt_fac_iso <- lm(congruent_aligned ~ isolated, ccfe_rt)
summary(lm_ccfe_rt_fac_iso)
```

```{r}
ccfe_rt <- ccfe_rt %>% 
  mutate(fac_regr_iso = residuals(lm_ccfe_rt_fac_iso))
ccfe_rt
```


Interference
```{r}
lm_ccfe_rt_int <- lm(incongruent_aligned ~ incongruent_misaligned, ccfe_rt)
summary(lm_ccfe_rt_int)
```

```{r}
ccfe_rt <- ccfe_rt %>% 
  mutate(int_regr = residuals(lm_ccfe_rt_int))
ccfe_rt
```

Interference (isolated)
```{r}
lm_ccfe_rt_int_iso <- lm(incongruent_aligned ~ isolated, ccfe_rt)
summary(lm_ccfe_rt_int_iso)
```

```{r}
ccfe_rt <- ccfe_rt %>% 
  mutate(int_regr_iso = residuals(lm_ccfe_rt_int_iso))
ccfe_rt
```


## Reliability of measurement

```{r}
df_pw_rel <- df_tidy %>% 
  filter(Task_name == "PW",
         Feature != "nose" ) %>%  # do not include Nose trials in GLMM
  # select(Subject, PW, Feature, Correct, RT, stim) %>% 
  mutate(stim = paste0("s", as.integer(as.factor(stim)))) %>% 
  filter(stim!="s19")  # do not need this in later analysis
  
```

```{r}
df_scf_rel <- df_tidy %>% 
  filter(Task_name == "SCF",
         SameDifferent == "same") %>% 
  group_by(Subject, Alignment, StimGroup) %>% 
  summarize(acc = mean(Correct), rt = mean(RT),
            .groups = "drop")
  # select(Subject, PW, Feature, Correct, RT, stim) %>% 
```



### Prepare data
Needs to prepare data for `Lambda4::lambda2()`: each row is one participant and each column is one trial (e.g., with the same stimuli) for each condition in each task separately.  
```{r}
df_tidy %>%
  filter(Task_name == "PW",
         Feature != "nose" ) %>%  # do not include Nose trials in GLMM
  # select(Subject, PW, Feature, Correct, RT, stim) %>% 
  mutate(stim = paste0("s", as.integer(as.factor(stim)))) %>% 
  filter(stim!="s19") %>%  # do not need this in later analysis
  pivot_wider(Subject, values_from = Correct, names_from = stim) %>% 
  data.matrix() %>% 
  lambda2()
```

```{r warning=FALSE}
df_tidy %>%
  filter(Task_name == "PW",
         Feature != "nose" ) %>%  # do not include Nose trials in GLMM
  # select(Subject, PW, Feature, Correct, RT, stim) %>% 
  mutate(stim = paste0("s", as.integer(as.factor(stim)))) %>% 
  filter(stim!="s19") %>%  # do not need this in later analysis
  pivot_wider(Subject, values_from = Correct, names_from = stim) %>% 
  data.matrix() %>%
  psych::guttman()
```


```{r}
df_scf_rel %>%
  filter(Alignment=="aligned") %>% 
  pivot_wider(Subject, values_from = acc, names_from = StimGroup) %>% 
  data.matrix() %>% 
  lambda2(standardize=TRUE)
```

```{r}
df_scf_rel %>%
  filter(Alignment=="aligned") %>% 
  pivot_wider(Subject, values_from = acc, names_from = StimGroup) %>% 
  data.matrix() %>% 
  splitHalf(check.keys=FALSE)
```

```{r}
df_scf_rel %>%
  filter(Alignment=="misaligned") %>% 
  pivot_wider(Subject, values_from = acc, names_from = StimGroup) %>% 
  select(-Subject) %>% 
  data.matrix() %>% 
  lambda2(missing="pairwise", standardize=TRUE)
```

```{r}
df_scf_rel %>%
  filter(Alignment=="misaligned") %>% 
  pivot_wider(Subject, values_from = acc, names_from = StimGroup) %>% 
  select(-Subject) %>% 
  data.matrix() %>% 
  splitHalf(check.keys=FALSE)
```

```{r}
sigmar <- df_scf_rel %>%
  filter(Alignment=="misaligned") %>% 
  pivot_wider(Subject, values_from = acc, names_from = StimGroup) %>% 
  select(-Subject) %>% 
  data.matrix() %>% 
  cor()

n <- nrow(sigmar)
sigma0 <- sigmar
diag(sigma0) <- 0

gamma2<-sum(sigma0^2)
L1<-1-sum(diag(sigmar))/sum(sigmar)

lambda2<-L1+sqrt((n/(n-1))*gamma2)/sum(sigmar)
lambda2
```


```{r}

sumr <- sum(sigmar)
 off <- sigmar
diag(off) <- 0
sumsq.off <- sum(off^2)
sum.off <- sumr - tr(sigmar)
alpha <- (sum.off/sumr) * n/(n-1)
lambda2 <- (sum.off+ sqrt(sumsq.off*n/(n-1)))/sumr
lambda2
```



```{r}
df_scf_rel %>%
  filter(Alignment=="aligned") %>% 
  pivot_wider(Subject, values_from = rt, names_from = StimGroup) %>% 
  data.matrix() %>% 
  lambda2(standardize=TRUE)
```

```{r}
df_scf_rel %>%
  filter(Alignment=="aligned") %>% 
  pivot_wider(Subject, values_from = rt, names_from = StimGroup) %>% 
  data.matrix() %>% 
  splitHalf(check.keys=FALSE)
```


```{r}
df_scf_rel %>%
  filter(Alignment=="misaligned") %>% 
  pivot_wider(Subject, values_from = rt, names_from = StimGroup) %>% 
  data.matrix() %>% 
  lambda2()
```

```{r}
df_scf_rel %>%
  filter(Alignment=="misaligned") %>% 
  pivot_wider(Subject, values_from = rt, names_from = StimGroup) %>% 
  data.matrix() %>% 
  splitHalf(check.keys=FALSE)
```


```{r}
df_tidy %>%
  mutate(Task_name == "CCF") %>% 
  # select(Subject, PW, Feature, Correct, RT, stim) %>% 
  pivot_wider(Subject, values_from = Correct, names_from = stim) %>% 
  data.matrix() %>% 
  lambda2()
```


## Correlations among holistic processing effects

```{r}
# equivalence interval
delta_null_hp <- .15  # the equivalent interval will be [-delta_null_hp, delta_null_hp]

df_equi_hp <- tibble(
  Scenarios = paste("Scenario", 1:6),
  CI_low = c(delta_null_hp-.05, -delta_null_hp-.08, -delta_null_hp+.02, -.04, -delta_null_hp-.04, -delta_null_hp-.02),
  CI_upp = CI_low + c(rep(0.2, 5), 0.34)
) %>% 
  mutate(Scenarios = factor(Scenarios),
         Scenarios = factor(Scenarios, levels = rev(levels(Scenarios))))

plot_equi_hp <- ggplot(df_equi_hp, aes(xmin = CI_low, xmax = CI_upp, y = Scenarios)) +
  geom_errorbarh(height = .4, color = c("#D55E00", "#D55E00", "#56B4E9",
                                        "gray30", "gray30", "gray30"), size = 1) +  # , "gray30"
  geom_vline(xintercept = 0, linetype = "longdash") +
  geom_vline(xintercept = c(-delta_null_hp,delta_null_hp), linetype = "dashed", color = "gray30") +
  scale_x_continuous(limits = c(-.3, .3), breaks = c(-delta_null_hp, 0, delta_null_hp)) +
  xlab("Correlation coefficient") +
  papaja::theme_apa() +
  NULL

# ggsave("equivalence_test_hp.png", plot_equi_hp, width = 8, height = 5)

plot_equi_hp
```


## Correlations for facilitation and interference

```{r}
# equivalence interval
delta_null <- .15  # the equivalent interval will be [-delta_null, delta_null]

df_equi <- tibble(
  Scenarios = paste("Scenario", 1:7),
  CI_low = c(delta_null+.02, delta_null-.1, .03, -delta_null+.05, -.14, -delta_null-.03, -.05),
  CI_upp = CI_low + c(.2, .2, 0.1, .2, 0.1, .3, .3)
) %>% 
  mutate(Scenarios = factor(Scenarios),
         Scenarios = factor(Scenarios, levels = rev(levels(Scenarios))))

plot_equi <- ggplot(df_equi, aes(xmin = CI_low, xmax = CI_upp, y = Scenarios)) +
  geom_errorbarh(height = .4, color = c("#D55E00", "#D55E00", "#D55E00",
                                        "#56B4E9", "#56B4E9", "#56B4E9", "gray30"), size = 1) + 
  geom_vline(xintercept = 0, linetype = "longdash") +
  geom_vline(xintercept = delta_null, linetype = "dashed", color = "gray30") +
  scale_x_continuous(limits = c(-.25, .4), breaks = c(-delta_null, 0, delta_null)) +
  xlab("Correlation coefficient") +
  papaja::theme_apa() +
  NULL

# ggsave("equivalence_test.png", plot_equi, width = 8, height = 5)

plot_equi
```


### PW and Facilitation in CCF

#### Subtraction

```{r}
cor.test(pwe_acc$pwe_subt, ccfe_d$fac_subt)
```


```{r}
cor.test(pwe_acc$pwe_subt, ccfe_d$fac_subt_iso)
```

```{r}
cor.test(pwe_rt$pwe_subt, ccfe_rt$fac_subt)
```


```{r}
cor.test(pwe_rt$pwe_subt, ccfe_rt$fac_subt_iso)
```

#### Regressions

```{r}
cor.test(pwe_acc$pwe_regr, ccfe_d$fac_regr)
```


```{r}
cor.test(pwe_acc$pwe_regr, ccfe_d$fac_regr_iso)
```

```{r}
cor.test(pwe_rt$pwe_regr, ccfe_rt$fac_regr)
```


```{r}
cor.test(pwe_rt$pwe_regr, ccfe_rt$fac_regr_iso)
```

### SCF and Interference in CCF

#### Subtraction

```{r}
cor.test(scfe_acc$scfe_subt, ccfe_d$int_subt)
```

```{r}
cor.test(scfe_acc$scfe_subt, ccfe_d$int_subt_iso)
```

```{r}
cor.test(scfe_rt$scfe_subt, ccfe_rt$int_subt)
```

```{r}
cor.test(scfe_rt$scfe_subt, ccfe_rt$int_subt_iso)
```

#### Regressions

```{r}
cor.test(scfe_acc$scfe_regr, ccfe_d$int_regr)
```

```{r}
cor.test(scfe_acc$scfe_regr, ccfe_d$int_regr_iso)
```

```{r}
cor.test(scfe_rt$scfe_regr, ccfe_rt$int_regr)
```

```{r}
cor.test(scfe_rt$scfe_regr, ccfe_rt$int_regr_iso)
```

### Pairwise correlations

```{r}
library(corrplot)
```

#### Performance

```{r}
left_join(pwe_acc, scfe_acc, by="Subject") %>% 
  left_join(ccfe_d, by="Subject") %>% 
  select(-Subject) %>% 
  cor() %>% 
  corrplot(type = "upper", order = "hclust", 
          tl.col = "black", tl.srt = 45)
```


#### Response times

```{r}
left_join(pwe_rt, scfe_rt, by="Subject") %>% 
  left_join(ccfe_rt, by="Subject") %>% 
  select(-Subject) %>% 
  cor() %>% 
  corrplot(type = "upper", order = "hclust", 
          tl.col = "black", tl.srt = 45)
```


# Session information {.unlisted .unnumbered}
```{r}
sessionInfo()
```
